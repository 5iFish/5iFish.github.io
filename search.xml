<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Python3.5学习（五）</title>
      <link href="/2018/08/14/Python3.5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2018/08/14/Python3.5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>模块定义、导入、优化</li><li>内置模块</li><li>正则表达式</li></ul><a id="more"></a><h1 id="模块定义、导入、优化"><a href="#模块定义、导入、优化" class="headerlink" title="模块定义、导入、优化"></a>模块定义、导入、优化</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>模块：本质是python文件，用来从逻辑上组织python代码（变量、函数、类、逻辑），为了实现其中的功能<br>包：本质是目录（必须带有<strong>init</strong>.py）</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>a:标准库<br>b:开源模块<br>c:自定义模块  </p><blockquote><p><strong><em>注意：为自定义的模块命名时，不要与标准库和电脑上安装的第三方模块名字相同</em></strong></p></blockquote><h2 id="导入方法"><a href="#导入方法" class="headerlink" title="导入方法"></a>导入方法</h2><h3 id="调用模块"><a href="#调用模块" class="headerlink" title="调用模块"></a>调用模块</h3><h4 id="imoort"><a href="#imoort" class="headerlink" title="imoort"></a>imoort</h4><p>import module :调用整个模块<br>使用模块时通过module_name.def_name来调用模块中的方法。</p><pre><code>#目录结构如下：+--dirname|  +--func.py+--+--main.py</code></pre><p>func.py</p><pre><code>#f函数，保存在func.py文件中name = &apos;func&apos;def show_f():    print(&quot;This is in func&quot;)</code></pre><p>main.py</p><pre><code>#main.py保存在与func.py相同的目录先import funcname = &apos;main&apos;def show_m():    print(&quot;This is in main&quot;)print(func.name,name)func.show_f()show_m()&apos;&apos;&apos;结果为：func mainThis is in funcThis is in main&apos;&apos;&apos;</code></pre><h4 id="from-import"><a href="#from-import" class="headerlink" title="from import"></a>from import</h4><p>from module_name frome def_name:调用模块中的方法<br>使用方法时，直接通过def_name()调用。</p><pre><code>#目录结构如下：+--dirname|  +--func.py+--+--main.py</code></pre><p>func.py  </p><pre><code>#f函数，保存在func.py文件中name = &apos;func&apos;def show_f():    print(&quot;This is in func&quot;)</code></pre><p>main.py</p><pre><code>#main.py保存在与func.py相同的目录先from func import show_fname = &apos;main&apos;def show_m():    print(&quot;This is in main&quot;)#由于没有调用name，因此name为main中的nameprint(name)show_f()show_m()&apos;&apos;&apos;结果为：mainThis is in funcThis is in main&apos;&apos;&apos;</code></pre><blockquote><p><strong><em>注意：引用模块中的函数不要与本程序中的函数重名</em></strong></p></blockquote><h3 id="调用包"><a href="#调用包" class="headerlink" title="调用包"></a>调用包</h3><p>直接通过import调用包时候，只调用了包中<strong>init</strong>.py中的内容，并且不能使用包中的其他模块<br>调用模块时，使用frome package_name import moudle_name 来调用</p><blockquote><p><strong><em>注意：包与目录的区别，文件夹中必须包含有<strong>init</strong>.py文件在python中才被识别为包</em></strong></p></blockquote><p>示例文件目录结构如下： </p><pre><code>+--dirname|  +--package|  |  +--bin|  |  |  +--atm.py|  |  |  +--__init__.py|  |  +--conf|  |  |  +--config.py|  |  |  +--__init__.py|  |  +--__init__.py+--+--test.py</code></pre><p><strong>1.import package:</strong></p><p>test.py内容如下:</p><pre><code>import package</code></pre><p>package/bin/atm.py内容如下：</p><pre><code>name = &apos;package/bin/atm&apos;print(&apos;this is in&apos;,name)</code></pre><p>package/conf/config.py内容如下:</p><pre><code>name = &apos;package/conf/config&apos;print(&apos;this is in&apos;,name)</code></pre><p>package/<strong>init</strong>.py内容如下:</p><pre><code>name = &apos;package/__init__&apos;print(&apos;this is in&apos;,name)</code></pre><p>运行test.py我们得到结果如下：</p><pre><code>&apos;&apos;&apos;this is in package/__init__&apos;&apos;&apos;</code></pre><p>可以看到当直接import package时程序只执行了package中的<strong>init</strong>.py</p><p><strong>2.from package import moudle</strong>  </p><p>将上面test.py中的内容改为:</p><pre><code>from package.bin import atm</code></pre><p>结果为：</p><pre><code>this is in package/__init__this is in package/bin/atm</code></pre><p>可以发现from import的方式调用包时，遇到包也会首先执行包中的<strong>init</strong>模块，再执行其他模块</p><h2 id="import的本质"><a href="#import的本质" class="headerlink" title="import的本质"></a>import的本质</h2><p>import本质就是路径搜索和搜索路径，导入模块的本质就是把python文件解释一遍。导入包的本质就是执行<strong>init</strong>.py文件</p><p>下面根据上一小节的package示例来详细说明import的本质<br>在上一小节中我们使用from package import moudle时test.py文件可以直接通过from package.bin import atm来调用atm模块。<br>接下来我们通过config.py文件来调用atm模块。<br>config.py中的内容改为：</p><pre><code>from package.bin import moudlename = &apos;package/__init__&apos;print(&apos;this is in&apos;,name)</code></pre><p>我们依然通过from package.bin import atm方式来调用atm模块，运行一下看看会发生什么：</p><pre><code>&apos;&apos;&apos;ModuleNotFoundError: No module named &apos;package&apos;&apos;&apos;&apos;</code></pre><p>报错：没有叫package的模块名。<br>what???我们创建的文件夹下面明明有package模块。<br>我们来看看问题出来哪里，在本节中我们说了Import就是路径搜索，那么我们需要调用一些模块来看一下系统搜索模块的路径列表。<br>下面是一些与文件路径有关的命令</p><pre><code>os.path.abspath(__file__)#获取文件的物理路径os.path.dirname()#获取上一级目录名sys.path#python搜索模块的路径，以列表形式保存sys.path.append()#将路径添加到搜索路径中sys.path.insert(0,path)#插入第一位os.getcwd()#获取当前工作路径&apos;&apos;&apos;os.path.abspath(__file__)与os.getcwd()本质区别:getcwd返回的是程序的工作的目录，并不是所在文件的物理路径abspath(__file__)返回的是程序的物理路径，不受当前工作目录影响&apos;&apos;&apos;</code></pre><p>我们先来看一下sys.path,config.py中的内容改为：</p><pre><code>import sysname = &apos;package/conf/config&apos;print(&apos;this is in&apos;,name)print(sys.path)</code></pre><p>结果为:</p><pre><code>this is in package/conf/config[&apos;D:\\Study\\Python练习\\PycharmProjects\\01. PY基础\\Day5\\module\\package\\conf&apos;, &apos;D:\\Study\\Python练习\\PycharmProjects\\01. PY基础&apos;, &apos;D:\\Study\\Python练习\\PycharmProjects\\01. PY基础\\venv\\Scripts\\python36.zip&apos;, &apos;C:\\Users\\zt122\\AppData\\Local\\Programs\\Python\\Python36\\DLLs&apos;, &apos;C:\\Users\\zt122\\AppData\\Local\\Programs\\Python\\Python36\\lib&apos;, &apos;C:\\Users\\zt122\\AppData\\Local\\Programs\\Python\\Python36&apos;, &apos;D:\\Study\\Python练习\\PycharmProjects\\01. PY基础\\venv&apos;, &apos;D:\\Study\\Python练习\\PycharmProjects\\01. PY基础\\venv\\lib\\site-packages&apos;, &apos;D:\\Study\\Python练习\\PycharmProjects\\01. PY基础\\venv\\lib\\site-packages\\setuptools-28.8.0-py3.6.egg&apos;, &apos;C:\\Program Files\\JetBrains\\PyCharm 2018.1.4\\helpers\\pycharm_matplotlib_backend&apos;]</code></pre><p>第一个为运行的文件所在的目录，第二个为pycharm创建项目时候自动添加的项目目录，其他均为自带的标准库和第三方库的目录。<br>当config.py在import的时候，仅仅搜索了conf文件夹。这里当然没有package。因此我们在调用时应该在系统中加入package所在的目录<br>config.py应改为：</p><pre><code>import sys,ospackage_dirpath =  os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))sys.path.append(package_dirpath)from package.bin import atmname = &apos;package/conf/config&apos;print(&apos;this is in&apos;,name)</code></pre><p>结果为：</p><pre><code>this is in package/__init__this is in package/bin/atmthis is in package/conf/config</code></pre><p>我们发现只要调用package就会执行一遍<strong>init</strong>.py模块，atm模块也如愿被成功调用</p><h2 id="import优化"><a href="#import优化" class="headerlink" title="import优化"></a>import优化</h2><p>1.使用import module来调用模块时，每次module.func()都会寻找一次模块。<br>而使用from module import func时候，调用func不同寻找模块直接调用，需要注意的是调用的函数名不要与程序中的有重复的。</p><p>2.在做程序的时候我们常常采用软件目录的规范来写程序，但是就会出现import的时候添加在搜索路径列表中的路径过多，可能存在相同的模块名在不同的路径中出现，在调用的时候系统会调用先添加进去的模块，就会出现错误。  </p><blockquote><p><strong><em>建议：个人感觉比较好的解决办法是通过将软件整体的目录所在的路径添加到列表中,之后都采用包调用的方式来调用不同目录中的模块，这样我们只需要在程序的主入口添加路径，其他地方都通过from package import moudle的方式调用即可。这样有效避免的搜索路径的困扰</em></strong></p></blockquote><h1 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h1><h2 id="time"><a href="#time" class="headerlink" title="time"></a>time</h2><pre><code>#1. time 格式化字符串#2. time 时间戳import timeprint(time.time())#3. 元组形式print(time.localtime())#时区与UTC相比，早的为-，28800/3600=8，中国在utc+8区print(time.timezone)#time.sleep()睡几秒time.sleep(1)#时间戳转换成utc时间元组print(time.gmtime())#时间戳转换为本地时区元组print(time.localtime())x=time.localtime()print(x)#调出年：print(x.tm_year)#查找时间戳为一年的第多少天：print(x.tm_yday)#将元组的形式转换为时间戳print(time.mktime(x))#strftime(format,tuple)元组转换为格式化字符串y = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,x)print(y)#strptime(x,format)格式化字符串转化成元组print(time.strptime(y,&quot;%Y-%m-%d %H:%M:%S&quot;))#asctime():转换元组到字符串默认格式：星期 月 日期 时间 年print(time.asctime())#Sun Jul 22 15:01:07 2018#ctime():转换时间戳到字符串模式</code></pre><h2 id="datatime"><a href="#datatime" class="headerlink" title="datatime"></a>datatime</h2><pre><code>import  datetime#显示当前时间print(datetime.datetime.now())#对datetime增减：# datetime.timedelta()# (正数加负数减)，对小时操作：hours = 3s = datetime.datetime.now()print(s+datetime.timedelta(3))print(s+datetime.timedelta(hours=3))print(s+datetime.timedelta(minutes=-2))#时间替换c_time = datetime.datetime.now()print(c_time.replace(day=21,month=6))</code></pre><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><pre><code>#Author:ztimport random#random()随机[0,1)之间的小数print(random.random())#randint(1,7)随机[a,b]之间的整数print(random.randint(1,7))#randrange(1,3)随机[1,7)之间的整数，不包含7print(random.randrange(1,3))#结果为1或2#random.choice(&quot;hello&quot;)随机从序列(可以通过[数字]或者(数字)取值的)中取值#可以是字符串、列表#不可以是元组、字典x= [&apos;你好&apos;,&quot;再见&quot;]print(random.choice(x))y = &apos;你好啊&apos;print(random.choice(y))#random.sample(序列,长度)# 返回n个随机从序列中提取的元素的列表print(random.sample(&quot;jfdisofjo&quot;,3))#uniform:可以指定区间取值，浮点数print(random.uniform(1,100))#shuffle(items)洗牌功能：将列表都打乱，随机排序random.shuffle(x)print(x)</code></pre><h3 id="实例：验证码生成器"><a href="#实例：验证码生成器" class="headerlink" title="实例：验证码生成器"></a>实例：验证码生成器</h3><pre><code>#随机生成包含数字和字母的验证码import randomn = int(input(&quot;请输入要定义几位的验证码&quot;))while True:    #创建空验证码    checkcode = &quot;&quot;    #判断是否存在字符    isstr = False    for i in range(n):        current = random.randrange(0,n)        #当current值为其所在位置编号时，则输出字母        if current == i:            tmp = chr(random.randint(65,90))            isstr = True        else:            tmp = str(random.randint(0,9))        checkcode += tmp    #判断：如果验证码中存在字母打印并退出    if isstr:        print(checkcode)        break</code></pre><h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><pre><code>import os#显示当前的工作目录print(os.getcwd())#切换目录os.chdir(路径)：os.chdir(os.path.dirname(os.path.abspath(__file__)))#os.curdir返回当前目录 .print(os.curdir)#os.pardir返回当前目录的父目录 ..print(os.pardir)#os.makedirs(r&quot;路径&quot;):递归创建目录，从父级目录一直创建到最终目录#os.makedirs(r&quot;D:\Study\Python练习\PycharmProjects\PY1\Day5\abc&quot;)#os.removedirs:若目录为空则删除，并递归到上一级目录，依次类推# os.removedirs(r&quot;D:\Study\Python练习\PycharmProjects\PY1\Day5\abc&quot;)#os.mkdir(dirname):只能在已有目录下创建目录，不能递归创建#os.makedirs(r&quot;D:\Study\Python练习\PycharmProjects\PY1\Day5\abc&quot;)#os.rmdir(dirname):只删除目标目录，中间有空目录也不删除# os.makedirs(r&quot;D:\Study\Python练习\PycharmProjects\PY1\Day5\abc&quot;)#os.listdir(dirname):显示当前目录下所有的文件名，返回为列表os.listdir(os.getcwd())#os.remove:删除一个文件# os.remove(r&quot;D:\Study\Python练习\PycharmProjects\PY1\Day5\test.py&quot;)#os.rename(&quot;&quot;oldname,&quot;newname&quot;)重命名print(os.stat(os.path.abspath(__file__)))print(os.sep)#输出指定平台的目录分隔符print(os.linesep)#输出当前平台使用的行终止符 回车print(os.pathsep)#输出用于分割文件路径的字符串print(os.name)#输出字符串指示当前使用平台。win-&gt;nt linux-&gt;\nprint(os.system(&quot;ipconfig&quot;))#运行cmd命令，直接显示print(os.environ)#获取系统环境变量os.path.abspath(__file__)#获取文件的绝对路径print(os.path.split(os.getcwd()))#分割路径,返回连个元组，分割成目录和文件名二元组print(os.path.basename(os.path.abspath(__file__)))#返回path最后一个文件名print(os.path.exists(os.path.abspath(__file__)))#如果path存在返回True，不存在返回Falseprint(os.path.isabs(os.path.abspath(__file__)))#如果是绝对路径则返回Trueprint(os.path.isfile(os.path.abspath(__file__)))#如果path是一个存在的文件返回Trueprint(os.path.isdir(os.path.abspath(__file__)))#如果path是一个存在的目录则返回Trueprint(os.path.join(r&quot;c:\program&quot;,&apos;a&apos;,&apos;b&apos;,r&apos;d:\abc&apos;,&apos;c&apos;,&apos;d&apos;))#多路径组合返回，第一个绝对路径之前被忽略c_a =os.path.getatime(r&quot;c:\windows&quot;)#返回path指向目录或文件最后存取时间d_m = os.path.getmtime(r&quot;d:\application&quot;)#返回path指向目录或文件最后修改时间import timeprint(time.strftime(&quot;%Y %m %d %H:%M:%S&quot;,time.localtime(c_a)))print(time.strftime(&quot;%Y %m %d %H:%M:%S&quot;,time.localtime(d_m)))</code></pre><h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><pre><code>#argv:加入脚本参数import sys#命令行参数list,第一个元素为程序本身print(sys.argv)&apos;&apos;&apos;(venv) D:\Study\Python练习\PycharmProjects\PY1\Day5&gt;python sys_test.py 1 2 3[&apos;sys_test.py&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;](venv) D:\Study\Python练习\PycharmProjects\PY1\Day5&gt;&apos;&apos;&apos;#exit(n)退出程序，正常退出为0#sys.exit(0)#version:获取python版本信息print(sys.version)#maxsize:返回最大int值print(sys.maxsize)print(sys.path)#返回模块搜索路径print(sys.platform)#返回操作系统名称sys.stdout.write(&apos;please\n&apos;)#标准输出，sys.stdout.flush()制作进度条效果val = sys.stdin.readline()[:-1]print(val)</code></pre><h2 id="shelve"><a href="#shelve" class="headerlink" title="shelve"></a>shelve</h2><pre><code>#简单的k,v将内存数据通过文件持久化的模块，可持久化任何pickle可支持的python数据格式#特点是操作方便，而且调用时不用将全部的内容读进内存，通过字典的方式调用#序列化import shelveimport datetimed = shelve.open(&apos;shelve_test&apos;) #打开一个文件info = {    &apos;age&apos;:22,    &apos;job&apos;:&apos;it&apos;}name = [&quot;zt&quot;,&quot;rain&quot;,&quot;test&quot;]d[&quot;name&quot;] = name#持久化列表d[&quot;info&quot;] = info #持久化字典d[&quot;time&quot;] = datetime.datetime.now()d.close()&apos;&apos;&apos;生成三个文件.bak.dat.dir&apos;&apos;&apos;#反序列化：d=shelve.open(&apos;shelve_test&apos;)print(d.get(&quot;name&quot;))print(d.get(&quot;info&quot;))print(d.get(&quot;time&quot;))d.close()</code></pre><h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><h3 id="xml创建"><a href="#xml创建" class="headerlink" title="xml创建"></a>xml创建</h3><pre><code>import xml.etree.ElementTree as ET#根节点new_xml = ET.Element(&quot;namelist&quot;)#子节点#传递参数为：父节点，子节点名,标签属性person = ET.SubElement(new_xml,&quot;person&quot;,attrib= {&quot;enrolled&quot;:&quot;yes&quot;})name =  ET.SubElement(person,&quot;name&quot;)age = ET.SubElement(person,&quot;age&quot;,attrib={&quot;checked&quot;:&quot;no&quot;})sex = ET.SubElement(person,&quot;sex&quot;)#创建标签内容name.text = &quot;zle&quot;sex.text = &quot;女&quot;age.text = &quot;23&quot;person2 = ET.SubElement(new_xml,&quot;person&quot;,attrib= {&quot;enrolled&quot;:&quot;no&quot;})name2 =  ET.SubElement(person2,&quot;name&quot;)age2 = ET.SubElement(person2,&quot;age&quot;)sex2 = ET.SubElement(person2,&quot;sex&quot;)name2.text = &quot;wss&quot;age2.text = &apos;19&apos;sex2.text = &quot;男&quot;et = ET.ElementTree(new_xml)#生成对象et.write(&quot;test.xml&quot;,encoding=&quot;utf-8&quot;,xml_declaration=True)ET.dump(new_xml)#打印生成格式</code></pre><h3 id="xml处理"><a href="#xml处理" class="headerlink" title="xml处理"></a>xml处理</h3><pre><code>import  xml.etree.ElementTree as ETtree = ET.parse(&quot;xmltest.xml&quot;)root = tree.getroot()#打印标签名print(root.tag)#遍历xmlfor child in root:    #打印标签名和属性    print(child.tag,child.attrib)    print(&apos;--------------------&apos;)    for i in child:        #打印标签和内容        print(i.tag,i.text)#只遍历年for node in root.iter(&quot;year&quot;):    print(node.tag,node.text)</code></pre><h3 id="xml修改"><a href="#xml修改" class="headerlink" title="xml修改"></a>xml修改</h3><pre><code>import xml.etree.ElementTree as ETtree = ET.parse(&quot;xmltest.xml&quot;)root = tree.getroot()#修改for node in root.iter(&quot;year&quot;):    new_year = int(node.text)+1    node.text = str(new_year)    #set:添加属性    node.set(&quot;updated&quot;,&quot;Yes&quot;)tree.write(&quot;xmltest.xml&quot;)#删除nodefor country in root.findall(&quot;country&quot;):    rank = int(country.find(&apos;rank&apos;).text)    if rank &gt;50:        root.remove(country)tree.write(&apos;output.xml&apos;)</code></pre><h2 id="configparser"><a href="#configparser" class="headerlink" title="configparser"></a>configparser</h2><h3 id="configparser生成"><a href="#configparser生成" class="headerlink" title="configparser生成"></a>configparser生成</h3><pre><code>import configparser#与字典操作相同config = configparser.ConfigParser()config[&quot;DEFAULT&quot;] = {&apos;ServerAliveInterval&apos;:&apos;45&apos;,                     &apos;Compression&apos;:&apos;yes&apos;,                     &apos;CompressionLevel&apos;:&apos;9&apos;}config[&apos;bitbucket.org&apos;] = {}config[&apos;bitbucket.org&apos;][&apos;User&apos;] = &apos;hg&apos;config[&apos;topsecret.server.com&apos;]={}topsecret= config[&apos;topsecret.server.com&apos;]topsecret[&apos;Host Port&apos;] = &apos;50022&apos;topsecret[&apos;ForwardX11&apos;] = &apos;no&apos;config[&apos;DEFAULT&apos;][&apos;ForwardX11&apos;]=&apos;yes&apos;with open(&apos;example.ini&apos;,&apos;w&apos;) as configfile:    config.write(configfile)</code></pre><h3 id="configparser读改"><a href="#configparser读改" class="headerlink" title="configparser读改"></a>configparser读改</h3><pre><code>import configparserconf = configparser.ConfigParser()conf.read(&quot;example.ini&quot;)#不打印DEFAULT，打印其他的&quot;key&quot;print(conf.sections())print(conf[&apos;bitbucket.org&apos;][&apos;user&apos;])#改写sec = conf.remove_section(&apos;bitbucket.org&apos;)conf.write(open(&apos;example_mo.ini&apos;,&apos;w&apos;))</code></pre><h2 id="hashlib"><a href="#hashlib" class="headerlink" title="hashlib"></a>hashlib</h2><pre><code>import hashlibm = hashlib.md5()m.update(b&quot;hello&quot;)print(m.hexdigest())m.update(b&quot;It&apos;s me&quot;)print(m.hexdigest())m.update(b&quot;It&apos;s been a long time since last time we...&quot;)m2 = hashlib.md5()m2.update(b&quot;helloIt&apos;s me&quot;)print(m2.hexdigest())s2 = hashlib.sha1()s2.update(b&quot;helloIt&apos;s me&quot;)print(s2.hexdigest())&apos;&apos;&apos;结果为：5d41402abc4b2a76b9719d911017c59264f69d95135bc13d4827f871b37f780f64f69d95135bc13d4827f871b37f780f499cae7df71137c382efff67c03b1c936b4cc4ff只要内容相同md5就相同&apos;&apos;&apos;</code></pre><h2 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h2><pre><code>#高级的文件、文件夹、压缩包 处理模块import shutil#copyfileobj(文件句柄1,文件句柄2)将文件1拷贝到文件2f1 = open(&quot;file&quot;,encoding=&apos;utf-8&apos;)f2 = open(&quot;file_copy&quot;,&apos;w&apos;,encoding=&apos;utf-8&apos;)shutil.copyfileobj(f1,f2)f1.close()f2.close()#copyfile(文件名1,文件名2)直接输入文件名就可以拷贝shutil.copyfile(&quot;file&quot;,&quot;file_copy2&quot;)#copymode(文件1，文件2)仅copy权限，不copy用户、属组内容#copystat():拷贝状态信息不copy内容shutil.copystat(&quot;file&quot;,&quot;file_copy2&quot;)#copy:拷贝文件和权限#copy2:拷贝文件和状态信息#copytree()递归的copy,完整copy目录shutil.copytree(&quot;module&quot;,&quot;shutil_module&quot;)#rmtree()递归的删除目录,全部删除目录下的所有东西shutil.rmtree(&quot;shutil_module&quot;)&apos;&apos;&apos;make_archive(base_name,format,...)创建压缩包并返回文件路径base_name:压缩包的文件名，可以是路径format:压缩包的种类:&quot;zip&quot;,&quot;tar&quot;,&quot;bztar&quot;,&quot;gztar&quot;root_dir:要压缩的文件夹路径（默认当前）owner:用户，默认当前group:组，默认当前logger:用于记录日志&apos;&apos;&apos;#返回压缩包文件名a=shutil.make_archive(&apos;module&apos;,&apos;zip&apos;,r&apos;D:\Study\Python练习\PycharmProjects\PY1\Day5\module&apos;)print(a)#对压缩包处理是调用ZipFile和TarFile方法#zipfile模块,可以把压缩包打开一个一个压缩文件import zipfilez = zipfile.ZipFile(&quot;module_test.zip&quot;,&apos;w&apos;)z.write(&quot;module.zip&quot;)print(&quot;zip module&quot;)z.write(&quot;sys_test.py&quot;)print(&quot;zip sys_test&quot;)z.close()</code></pre><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>第一部分：</p><pre><code>#匹配字符串import re#match 匹配,\d+后面取数字，直到取到字符res = re.match(&quot;^张三\d+&quot;,&apos;张三213来啊&apos;)print(res.group())#&apos;.&apos;默认匹配除\n之外的任意字符，若指定flag DOTALL则匹配任意字符，包括换行res2 = re.match(&quot;^.+\d&quot;,&apos;张三213来啊\n666&apos;)print(res2.group())#&apos;^&apos;匹配字符开头,若指定flags MULTILINE,也可匹配上(r&quot;^a&quot;,&quot;\nabc\nee&quot;)#&apos;.&apos;res3 = re.match(&quot;^&quot;,&quot;张三0342来不来&quot;)print(res3)#match:从头匹配#search使用最多#a$表示匹配到以a为结尾，$判断是不是以某一个字符结尾res4 = re.search(&quot;3.+$&quot;,&quot;张三0342来不来&quot;)print(res4)#a.+b表示从a匹配到b#&quot;R[a-z]+a&quot;表示从R取字母一直到第一个ares5 = re.search(&quot;R[a-z]+i&quot;,&quot;CzRsdjfi45a&quot;)print(res5)#&quot;R[a-zA-Z]+a&quot;可以取到R-a之间的大小写字母#ab*:匹配*前的数字一次或多次,findall返回全部匹配值res6 =re.findall(&quot;ab*&quot;,&quot;dfiabdueabbab&quot;)print(res6)#ab?匹配?前1个字符一次或0次，表示b不确定有，先匹配到a或者ab都可以返回res7 = re.search(&quot;ab?&quot;,&quot;aaaababbbaa&quot;)print(res7)#{n}表示想匹配几个，[0-9]{3}表示要匹配连续的三个0-9数字res8 =  re.search(&quot;[a-z]{4}&quot;,&quot;324sdnijf354&quot;)print(res8)#{a,b}表示匹配连续的字母，最多b次，最少a次res8 =  re.findall(&quot;[a-z]{1,4}&quot;,&quot;sdf324sdnijf354&quot;)print(res8)#|表示匹配|左面或者|右面的字符res9 = re.search(&quot;abc|ACB&quot;,&quot;abcda|BACBD&quot;)print(res9.group())#(...)分组匹配res10 = re.search(&quot;(abc){2}(\|\|=){2}&quot;,&quot;abcabc||=||=dddf&quot;)print(res10.group())&apos;&apos;&apos;结果为：张三213张三213&lt;_sre.SRE_Match object; span=(0, 0), match=&apos;&apos;&gt;&lt;_sre.SRE_Match object; span=(3, 9), match=&apos;342来不来&apos;&gt;&lt;_sre.SRE_Match object; span=(2, 8), match=&apos;Rsdjfi&apos;&gt;[&apos;ab&apos;, &apos;abb&apos;, &apos;ab&apos;]&lt;_sre.SRE_Match object; span=(0, 1), match=&apos;a&apos;&gt;&lt;_sre.SRE_Match object; span=(3, 7), match=&apos;sdni&apos;&gt;[&apos;sdf&apos;, &apos;sdni&apos;, &apos;jf&apos;]abcabcabc||=||=&apos;&apos;&apos;</code></pre><p>第二部分：</p><pre><code>import re#\A以什么开头，\Z以什么结尾res0 = re.search(&quot;\A[0-9]+[a-z]+\Z&quot;,&quot;43543nuns&quot;)print(res0.group())#\D非数字res1 = re.search(&quot;\D+&quot;,&quot;43543_=nuns&quot;)print(res1.group())#\w:匹配数字或字母#\W匹配非数字或字符#\s匹配空白字符res2 = re.search(&quot;\s+&quot;,&quot;43543\n\t_=nuns&quot;)print(res2.group())#分组匹配：(?P&lt;name&gt;[range]+),使用groupdict输出为字典res3 = re.search(&quot;(?P&lt;id&gt;[0-9])&quot;,&quot;234sdfjid1234&quot;)print(res3.groupdict())# mail = input(&quot;请输入邮箱&quot;)# res4 = re.search(&quot;(?P&lt;mailid&gt;\w+)\W(?P&lt;mailtype&gt;\w+)\W(?P&lt;domain&gt;[a-zA-Z]+)&quot;#                  ,mail)# print(res4.groupdict())#split分割res5 = re.split(&quot;[0-9]+&quot;,&quot;djsfi324dsfji342fjsi564&quot;)print(res5)#sub:替换,sub(pattern,rep1,string,count=all,flags=0)res5 = re.sub(&quot;[0-9]+&quot;,&quot;|&quot;,&quot;djsfi324dsfji342fjsi564&quot;,2)print(res5)#反斜杠的困扰res6 = re.search(r&quot;\\&quot;,r&quot;abcd\12&quot;)print(res6.group())#忽略大小写：flags = re.Ires7 = re.search(&apos;[a-z]+&apos;,&apos;sfdiAS&apos;,flags=re.I)print(res7.group())#忽略起始换行res8 = re.compile().search(&quot;^a.+&quot;,&quot;\nadinenb\niduenf435&quot;,flags=re.M)print(res8.group())#s：匹配任意模式res9  = re.search(&quot;a.+f&quot;,&quot;dai\nuefs&quot;,flags=re.S)print(res9.group())&apos;&apos;&apos;结果为：43543nuns_=nuns{&apos;id&apos;: &apos;2&apos;}[&apos;djsfi&apos;, &apos;dsfji&apos;, &apos;fjsi&apos;, &apos;&apos;]djsfi|dsfji|fjsi564\sfdiASadinenbaiuef&apos;&apos;&apos;</code></pre>]]></content>
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3.5学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3.5学习（四）</title>
      <link href="/2018/07/16/Python3.5%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2018/07/16/Python3.5%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>装饰器</li><li>生成器</li><li>迭代器</li><li>Json与pickle数据序列化</li><li>软件目录结构规范</li></ul><a id="more"></a><hr><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>本质是函数，（装饰其他函数）就是为其他函数添加附加功能</p><pre><code>&apos;&apos;&apos;#例：计算程序运行消耗的时间import  timedef timmer(func):    def warpper(*args,**kwargs):        start_time = time.time()        func()        stop_time=time.time()        print(&apos;the func run time is %s&apos;%(stop_time-start_time))    return warpper@timmerdef test1():    time.sleep(3)    print(&apos;in the test1&apos;)test1()&apos;&apos;&apos;</code></pre><h2 id="2-原则"><a href="#2-原则" class="headerlink" title="2. 原则"></a>2. 原则</h2><ol><li>不能修改被装饰的函数的源代码</li><li>函数调用方式不能修改</li></ol><h2 id="3-储备知识"><a href="#3-储备知识" class="headerlink" title="3. 储备知识"></a>3. 储备知识</h2><ol><li>函数即“变量”</li></ol><p><img src="\images\函数即变量.jpg" alt="函数即变量.jpg"></p><ol start="2"><li>高阶函数</li></ol><pre><code>a:把一个函数名当做实参传给另外一个函数（在不修改被装饰函数源代码的情况下添加新的功能）b:返回值中包含函数名</code></pre><ol start="3"><li>嵌套函数</li></ol><p>高阶函数+嵌套函数=&gt;装饰器</p><h2 id="4-实现装饰器过程1"><a href="#4-实现装饰器过程1" class="headerlink" title="4. 实现装饰器过程1"></a>4. 实现装饰器过程1</h2><p>仅仅使用高阶函数来实现例子：</p><pre><code>import timedef bar():    time.sleep(3)    print(&quot;in the bar&quot;)def test1(func):    start_time= time.time()    func()  #run bar    stop_time = time.time()    print(&quot;the func run time is %s&quot;%(stop_time-start_time))#改变了源程序中的调用函数test1(bar)</code></pre><p>假如将最后一行的函数调用改为：</p><pre><code>bar = test1(bar)bar()</code></pre><p>可以发现抛开bar = test1(bar)我们没有更改原函数</p><h2 id="5-实现装饰器过程2"><a href="#5-实现装饰器过程2" class="headerlink" title="5. 实现装饰器过程2"></a>5. 实现装饰器过程2</h2><p>当我们采用有返回值调用修饰函数时，代码可以写成：</p><pre><code>def deco(func):    star_time=time.time()    func()    stop_time = time.time()    print(&quot;the func run time is %s&quot;%(stop_time-star_time))    return func#采用调用方式为：test1=deco(test1)test1()</code></pre><h2 id="6-实现装饰器过程3"><a href="#6-实现装饰器过程3" class="headerlink" title="6. 实现装饰器过程3"></a>6. 实现装饰器过程3</h2><p>我们发现运行结果中运行了两次func()，分析调用过程，我们发现deco(test1)中运行了一次func，test1又运行一次，我们要保证只调用一次源代码，因此要将deco中不运行func，因此我们可以使用嵌套函数：</p><pre><code>def timer(func):    def deco():        star_time=time.time()        func()        stop_time = time.time()        print(&quot;the func run time is %s&quot;%(stop_time-star_time))    return decodef test1():#我们发现在执行timer(test1)时，嵌套函数中只是定义了deco函数，并未发现deco()，只是返回了一个创建的局部函数的内存地址#因此在调用时，我们应该采用：test1=timer(test1)test1()#程序执行顺序为先为timer创建空间计时器，然后为test1创建空间原功能区#接下来执行timer(test1),计时器的空间地址f赋值给func,执行def deco()创建空间为新功能区#return deco,返回为新功能区的地址，赋值给test1，接下来调用test1()#由于test1指向新功能区，因此test1()执行新功能区的功能#其中func由于指向原功能区，因此func()为执行原功能区功能#最后将test1=timer(test1)替换为@timer写在需要添加装饰的函数前面#至此实现了装饰器的功能</code></pre><p>※重点理解：程序在运行时会从头一直到执行代码，为执行代码之前的函数、变量创建内存地址</p><h2 id="7-通用装饰器"><a href="#7-通用装饰器" class="headerlink" title="7. 通用装饰器"></a>7. 通用装饰器</h2><p>当执行装饰器的时候，有时候原函数有传递参数，因此多使用参数不固定的形式：</p><pre><code>def timer(func):    def deco(*args,**kwargs):#通用装饰器        star_time=time.time()        func(*args,**kwargs)        stop_time = time.time()        print(&quot;the func run time is %s&quot;%(stop_time-star_time))    return deco@timerdef test1():    time.sleep(3)    print(&apos;in the test1&apos;)@timerdef test2(name,*args):#参数不固定    time.sleep(3)    print(&apos;in the test2&apos;,name,*args)#test1=timer(test1)test1()test2(&apos;张三&apos;,&apos;23&apos;,&apos;男&apos;)</code></pre><h2 id="8-装饰器传参"><a href="#8-装饰器传参" class="headerlink" title="8. 装饰器传参"></a>8. 装饰器传参</h2><p>当有时候装饰器需要接收参数时，例如一个网站，用户登录home页的时候需要根据本地密码登录，登录到bbs的时候需要外部Idap验证时候，如何写一个用于登录的装饰器：</p><pre><code>user,passwd=&apos;张三&apos;,&apos;123456&apos;def auth(auth_type):    def outwrapper(func):        def wrapper(*args,**kwargs):            if auth_type == &quot;loc&quot;:                username=input(&quot;username:&quot;)                password=input(&quot;password:&quot;)                if user == username and passwd==password:                    print(&quot;User has pass&quot;)                    func(*args,**kwargs)                    return &quot;你好&quot;                else:                    exit(&quot;Invalid username or password&quot;)            elif auth_type ==&quot;ldap&quot;:                print(&quot;搞毛线ldap,不会&quot;)        return  wrapper    return outwrapperdef index():    print(&quot;welcome to index page&quot;)&apos;&apos;&apos;@auth(auth_type = &quot;loc&quot;)可以分解为：auth(auth_type = &apos;loc&apos;)home=auth(home)执行auth（auth_type = &quot;loc）这时auth指向了outwrapper,auth_type=&apos;loc&apos;执行home=auth(home)时，auth(home)将home赋值给了funct同时执行了outwrapper()返回wrapper重新赋值给了home ,home指向wrapper，home()执行了wrapper()&apos;&apos;&apos;@auth(auth_type = &quot;loc&quot;)def home():    print(&quot;welcome to home page&quot;)@auth(auth_type = &quot;ldap&quot;)def bbs():    print(&quot;welcome to bbs page&quot;)index()#home(1)#print(home())#home已经指向了wrapper,因此应该设置wrapper的返回值home()bbs()</code></pre><hr><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><h2 id="1-特点"><a href="#1-特点" class="headerlink" title="1. 特点"></a>1. 特点</h2><ol><li>避免内存浪费</li><li>循环生成所需数据</li><li>生成器只有在调用时才会生成相应的数据</li><li>只记录当前位置（不能向前调用）</li><li>只有一个方法<strong>next</strong>()方法</li></ol><p>列表生成式：</p><pre><code>def func(i):    i*=6    return iprint([func(i) for i in range(10)])print([i*2 for i in range(10)])#改成()为创建了生成器#调用才生成b=(i*2 for i in range(10))#通过__next__()来访问无法返回上一个，只能保存单前值#一般用循环print(b.__next__())print(b.__next__())print(b.__next__())# for i in b:#     print(i)</code></pre><h2 id="2-实例分析：斐波那契生成器"><a href="#2-实例分析：斐波那契生成器" class="headerlink" title="2. 实例分析：斐波那契生成器"></a>2. 实例分析：斐波那契生成器</h2><pre><code>def fib(max):    n,a,b=0,0,1    while n &lt; max:        #print(b)        #yield b相当于挂起目前的操作，将b的值返回给生成器，等待再执行next操作时继续之后的操作        yield b        #相当于        #t=(b,a+b)        #a=t(0)        #b=t(1)        a,b = b,a+b        n+=1    return  &apos;This is fib&apos;#出异常后打印消息#仅仅是创建了f生成器，并没有进入fib函数，也没有进行max=10的传参f=fib(10)while True:    try:        #调用了next(f)进入了生成器，待yield传回参数后赋值给x继续下一步操作        x=next(f)        print(&apos;f:&apos;,x)    except StopIteration as e:        #抓住bug并返回异常为生成器返回值        print(&apos;Generator return value:&apos;,e.value)        break</code></pre><h2 id="3-生成器并行"><a href="#3-生成器并行" class="headerlink" title="3. 生成器并行"></a>3. 生成器并行</h2><pre><code>import timedef consumer(name):    print(&quot;%s 准备吃包子了！&quot;%name)    while True:        #等待send输入，直到send()传递参数，再继续执行        baozi = yield        print(&quot;包子[%s]来了，被[%s]吃了！&quot;%(baozi,name))# c=comsumer(&quot;张三&quot;)# c.__next__()# b1=&quot;韭菜馅&quot;# c.send(b1)#send将b1传给了yield，并向下执行def producer(name):    c=consumer(&apos;A&apos;)    c2=consumer(&apos;B&apos;)    c.__next__()    c2.__next__()    print(&quot;老子开始做包子了&quot;)    for i in range(10):        time.sleep(1)        print(&quot;做了2个包子&quot;)        c.send(i)        c2.send(i)producer(&quot;alex&quot;)#协程</code></pre><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>可直接作用于for循环的数据类型有以下几种：</p><p>一类是集合数据类型，如list、tuple、dict、set、str等；</p><p>一类是generator，包括生成器和带yiel的generator function</p><p>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable.</p><p>可以使用isinstance()判断一个对象是否是Iterable对象</p><pre><code>#判断是否为可迭代对象from collections import Iterable,Iteratorprint(isinstance([],Iterable))print(isinstance(set(),Iterable))print(isinstance((),Iterable))print(isinstance({},Iterable))print(isinstance(&quot;你好&quot;,Iterable))print(isinstance(100,Iterable))print(&quot;==========end===========&quot;)#判断是否为迭代器对象print(isinstance((x for x in range(5)),Iterator))</code></pre><p>将可迭代对象变成迭代器</p><pre><code>#iter():将可迭代对象转变成迭代器c=iter(&apos;abc&apos;)print(c)print(c.__next__())print(c.__next__())print(c.__next__())</code></pre><h1 id="json与pickle序列化"><a href="#json与pickle序列化" class="headerlink" title="json与pickle序列化"></a>json与pickle序列化</h1><p>方法：dumps,dump,loads,load</p><p>dumps和dump，load和loads的区别：</p><p>dumps是将对象序列化</p><p>dump是将对象序列化并保存到文件中</p><p>loads将序列化字符串反序列化</p><p>load将序列化字符串从文件读取并反序列化</p><h2 id="1-json序列化"><a href="#1-json序列化" class="headerlink" title="1. json序列化"></a>1. json序列化</h2><pre><code>#序列化：将内存中的内容挂起，存到硬盘上的过程#多次dump时，会在文件中产生多条记录，导致不能load#重点：每个程序只dump一次，想多次dump要dump成不同的文件，或者将源文件冲掉import jsoninfo={    &apos;name&apos;:&apos;Alex&apos;,    &apos;age&apos;:23}f=open(&quot;test.txt&quot;,&quot;w&quot;,encoding=&apos;utf-8&apos;)#print(json.dumps(info))f.write(json.dumps(info))#与json.dump(info,f)相同f.close()</code></pre><h2 id="2-json去序列化"><a href="#2-json去序列化" class="headerlink" title="2. json去序列化"></a>2. json去序列化</h2><p>适用于多语言的数据传输</p><pre><code>import json#反序列化：将硬盘上的内容重载到内存中#f = open(&quot;test.txt&quot;,&apos;r&apos;)# data=f.read()# f.close()# print(data)f=open(&quot;test.txt&quot;,&apos;r&apos;)data = json.loads(f.read())#与data=json.load(f)相同print(data[&quot;age&quot;])</code></pre><h2 id="3-pickle序列化"><a href="#3-pickle序列化" class="headerlink" title="3. pickle序列化"></a>3. pickle序列化</h2><p>仅限python</p><pre><code>#pickle.dump自动变为二进制import pickledef sayhi(name):    print(&quot;Hello,&quot;,name)info={    &apos;name&apos;:&apos;Alex&apos;,    &apos;age&apos;:23,    &apos;func&apos;:sayhi}f=open(&quot;test.txt&quot;,&quot;wb&quot;)#print(json.dumps(info))f.write(pickle.dumps(info))f.close()</code></pre><h2 id="4-pickle反序列化"><a href="#4-pickle反序列化" class="headerlink" title="4. pickle反序列化"></a>4. pickle反序列化</h2><pre><code>import pickle#反序列化：将硬盘上的内容重载到内存中#f = open(&quot;test.txt&quot;,&apos;r&apos;)# data=f.read()# f.close()# print(data)def sayhi(name):    print(&quot;Hello,&quot;,name)    print(&quot;Hello2,&quot;,name)f=open(&quot;test.txt&quot;,&apos;rb&apos;)data = pickle.loads(f.read())print(data[&apos;func&apos;](&quot;Alex&quot;))</code></pre><h1 id="软件目录规范"><a href="#软件目录规范" class="headerlink" title="软件目录规范"></a>软件目录规范</h1><p><img src="\images\软件目录规范.jpg" alt="软件目录规范.jpg"></p>]]></content>
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3.5学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3.5学习（三）</title>
      <link href="/2018/07/16/Python3.5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2018/07/16/Python3.5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>函数式编程</li><li>函数</li><li>返回值</li><li>参数与变量</li><li>递归</li><li>匿名函数</li><li>高阶函数</li><li>内置方法</li></ul><a id="more"></a> <hr><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>函数式编程思维更接近数学计算</p><p>函数式编程是一种抽象程度很高的编程范式，纯粹的函数式编程<br>是没有变量的，因此，任意一个函数，只要输入是确定的输出<br>就是确定的，这种纯函数我们称之为没有副作用。</p><p>举例：</p><pre><code>（1+2）*3-4</code></pre><p>传统编程：</p><pre><code>var a = 1+2;var b = a*3;car c = b-4;</code></pre><p>函数式编程：</p><pre><code>var result = subtract(multiply(add(1,2),3),4)</code></pre><p>函数式编程不是函数</p><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>1.面向对象：类    class<br>2.面向过程：过程    def<br>3.函数式编程：函数    def</p><p>python中函数定义方法：</p><pre><code>def test(x):    &quot;The function definitions&quot;    x+=1    return x&apos;&apos;&apos;def:定义函数的关键字test;函数名():定义形参&quot;&quot;:文档描述（非必要，建议为函数添加描述信息）x+=1:泛指代码块或程序处理逻辑return:定义返回值&apos;&apos;&apos;</code></pre><p>函数与过程：</p><pre><code>#函数def func1():    &quot;test&quot;    print(&apos;你好&apos;)    return 0#过程:没有返回值def func2():    &quot;test2&quot;    print(&apos;你好吗&apos;)x=func1()y=func2()print(&apos;from func1 return is&apos;,x)#0print(&apos;from func2 return is&apos;,y)#None</code></pre><p>函数调用的例子：写日志</p><pre><code>import timedef logger():    &quot;追加日志文件&quot;    #规范日期格式    time_format = &apos;%Y-%m-%d %X&apos;    time_current = time.strftime(time_format)    #写入日志    with open(&quot;function&quot;,&apos;a+&apos;) as f:        f.write(&quot;%s end action\n&quot;%time_current)def test1():    print(&quot;this is an apple&quot;)    logger()def test2():    print(&quot;this is a pen&quot;)    logger()def test3():    print(&quot;this is a penapple&quot;)    logger()test1()test2()test3()</code></pre><hr><h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>函数中用return返回参数</p><pre><code>def test1():    &quot;test1&quot;    print(&quot;this is test1&quot;)    return 0    #函数遇到return就结束，不往下进行    print(&quot;hi&quot;)def test2():    print(&quot;this is test2&quot;)def test3():    print(&quot;this is test3&quot;)    #可以返回多个类型数据，函数返回的为这些数据组成的元组    return 1,&apos;hello&apos;,[&apos;alex&apos;,&apos;wupeiqi&apos;],{&apos;name&apos;:&apos;alex&apos;}x=test1()y=test2()z=test3()print(x)print(y)print(z)&apos;&apos;&apos;结果为:this is test1this is test2this is test30None(1, &apos;hello&apos;, [&apos;alex&apos;, &apos;wupeiqi&apos;], {&apos;name&apos;: &apos;alex&apos;})&apos;&apos;&apos;</code></pre><hr><h1 id="参数与变量"><a href="#参数与变量" class="headerlink" title="参数与变量"></a>参数与变量</h1><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><pre><code>def test(x,y):    print(x)    print(y)test(y=2,x=1)#关键字调用与形参顺序无关test(2,1)#与形参一一对应#test(x=2,3)#SyntaxError: positional argument follows keyword argument#test(2,x=3)#TypeError: test() got multiple values for argument &apos;x&apos;test(2,y=3)#位置参数要在关键字参数之后&apos;&apos;&apos;默认形参:调用时候默认参数为非必须传递参数用途：默认目录、默认值&apos;&apos;&apos;def test2(x,y=2):    print(x)    print(y)test2(2)test2(1,y=3)&apos;&apos;&apos;当需要传递参数不固定时需要使用参数组形参参数组,接收的位置参数args接收位置参数转换成数组模式&apos;&apos;&apos;def test3(x,*args):    print(x)    print(args)test3(1,2,3,4)&apos;&apos;&apos;传递字典传递时把多个关键字参数转换成字典的方式def test4(**kwargs):    print(kwargs)    print(kwargs[&apos;name&apos;])    print(kwargs[&apos;age&apos;])test4(name=&apos;alex&apos;,age=8,sex=&apos;F&apos;)test4(**{&apos;name&apos;:&apos;Alex&apos;,&apos;age&apos;:&apos;8&apos;})&apos;&apos;&apos;def test5(name,**kwargs):    print(name)    print(kwargs)test5(&apos;alex&apos;,age=8,sex=&apos;F&apos;)def test6(name,age=18,**kwargs):    print(name)    print(age)    print(kwargs)test6(&apos;alex&apos;,sex=&apos;m&apos;,hobby=&apos;tesla&apos;,age=26)def test7(name,*args,**kwargs):    print(name)    print(args)    print(kwargs)    logger(&quot;test7&quot;)#test7(&apos;alex&apos;,sex=&apos;m&apos;,hobby=&apos;tesla&apos;)# 程序执行到这里不会向下执行了因此会报错由于没有读到logger()def logger(source):    print(&quot;from%s&quot;%source)test7(&apos;alex&apos;,sex=&apos;m&apos;,hobby=&apos;tesla&apos;)</code></pre><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><pre><code>#字符串和整数变量：school = &quot;NEU&quot;def change_name(name):    global school#声明要更改全局变量,可创建全局变量，不要使用    school = &quot;NNU&quot;#school变成了局部变量    print(&quot;before change:{s},school:{d}&quot;.format(s=name,d=school))    #局部变量，只作用于函数    name=&quot;Alex Li&quot;#作用域为此函数    print(&quot;after change&quot;,name)name = &quot;Alex&quot;change_name(name)print(&quot;%s,%s&quot;%(name,school))#列表变量：school = &quot;NEU&quot;names = [&quot;Alex&quot;,&quot;Jack&quot;,&quot;Rain&quot;]def change_name():    #除了字符串和整数不能修改，其他都可以改    names[0]=&quot;ahhh&quot;    print(names)change_name()print(names)</code></pre><hr><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归三个条件：</p><ol><li>递归要有明确的条件</li><li>每次进入更深层递归时，问题规模相比上一次应该有所减少</li><li>递归效率不高，递归层次多会导致栈溢出</li></ol><p>例子：</p><p>没有明确的终止条件：</p><pre><code>def calc(n):    print(n)    return calc(n/2)calc(10)</code></pre><p>正确的递归表达：</p><pre><code>def calc(n):    print(n)    if int(n/2)&gt;0:        return calc(int(n/2))    print(&apos;-&gt;&apos;,n)calc(10)&apos;&apos;&apos;结果为：10 5 2 1 -&gt;1&apos;&apos;&apos;</code></pre><hr><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><pre><code>#匿名函数针对不重复使用的函数def sayhi(n):    print(n)sayhi(3)(lambda n:print(n))(5)calc = lambda n:print(n)calc = lambda n:3 if n&lt;4 else nprint(calc(5))print(lambda x,y:x+y,range(10))</code></pre><hr><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>变量可以指向函数。函数的参数能接收变量，那么一个函数就能接收另一个函数作为参数，这种函数成为高阶函数</p><pre><code>def add(x,y,f):    return f(x)+f(y)res = add(3,-6,abs)print(res)</code></pre><hr><h1 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h1><pre><code># Author:ZT#all：判断结果，如果都为真则返回true，否则返回falseprint(all([0,-5,3]))#Fprint(all([1,-5,3]))#Tprint(&quot;---------------我是华丽的分割线---------------&quot;)#any:判断结果，任何元素为真则为真print(any([1,5,0]))#Tprint(any([0,0]))#Fprint(any([]))#Fprint(&quot;---------------我是华丽的分割线---------------&quot;)#ascii():转换成二进制形式，以字符串表示print(ascii(&quot;你好&quot;))a=ascii([3,4,&apos;李四&apos;])print([a])print(&quot;---------------我是华丽的分割线---------------&quot;)#bin()将数字转换成二进制print(bin(192))print(&quot;---------------我是华丽的分割线---------------&quot;)#bytearray:字节数组b=bytearray(&quot;abcde&quot;,encoding=&apos;utf-8&apos;)print(b[1])b[1]=50print(b)print(&quot;---------------我是华丽的分割线---------------&quot;)#callable()判断是否可以调用（后面可不可以加（））print(callable([]))#Fprint(&quot;---------------我是华丽的分割线---------------&quot;)#chr()返回asc码对应的字符print(chr(98))print(&quot;---------------我是华丽的分割线---------------&quot;)#ord()返回字符对应的asc码print(ord(&apos;c&apos;))print(&quot;---------------我是华丽的分割线---------------&quot;)#compile():用于将代码编译code= &quot;for i in range(10):print(i)&quot;compile(code,&apos;&apos;,&apos;exec&apos;)exec(code)print(&quot;---------------我是华丽的分割线---------------&quot;)code2=&quot;&quot;&quot;a=1b=2c=a+bprint(c)&quot;&quot;&quot;py_obj=compile(code2,&apos;&apos;,&apos;exec&apos;)exec(py_obj)print(&quot;---------------我是华丽的分割线---------------&quot;)code3 =&quot;1+3*4&quot;c3=compile(code3,&apos;&apos;,&apos;eval&apos;)eval(c3)print(&quot;---------------我是华丽的分割线---------------&quot;)#dir():查看方法a=set()print(dir(a))print(&quot;---------------我是华丽的分割线---------------&quot;)#divmod():相除并返回商和余数print(divmod(5,2))print(&quot;---------------我是华丽的分割线---------------&quot;)#filter()与lambda结合使用，用于过滤，是生成器#为已知序列每个元素调用给定函数的布尔运算，返回值为非零的添加res=filter(lambda n:n&gt;5,range(10))for i in res:    print(i)print(&quot;---------------我是华丽的分割线---------------&quot;)#map()按照lambda处理并返回结果，区别于filter#map()将函数调用映射到对应元素并返回含所有返回值的列表res=map(lambda  n:n*n,range(10))for i in res:    print(i)print(&quot;---------------我是华丽的分割线---------------&quot;)#reduce()import functoolsres=functools.reduce(lambda x,y:x+y,range(10))print(res)#frozenset:冻结集合，不可进行操作a=frozenset([1,2,3,1,4,8,5])print(&quot;---------------我是华丽的分割线---------------&quot;)#globals:返回当前文件所有的key-value的值#可以判断变量是否存在print(globals())print(&quot;---------------我是华丽的分割线---------------&quot;)#hash：散列表：使内容和序号形成映射print(hash(&quot;你好&quot;))print(&quot;---------------我是华丽的分割线---------------&quot;)#hex()将一个数字转成16进制print(hex(12))print(&quot;---------------我是华丽的分割线---------------&quot;)#locals()显示局部变量def test():    local_var = 333    print(locals())test()print(globals().get(&apos;local_var&apos;))print(&quot;---------------我是华丽的分割线---------------&quot;)#oct():转换成8进制print(oct(9))print(&quot;---------------我是华丽的分割线---------------&quot;)#repr()用字符串表示对象print(repr(test))print(&quot;---------------我是华丽的分割线---------------&quot;)#reversed()：反转后为生成器r=reversed([1,2,3,4,5,6])print(r.__next__())print(r.__next__())print(r.__next__())print(r.__next__())print(&quot;---------------我是华丽的分割线---------------&quot;)#round()取头几位小数print(round(123213.12132,2))print(round(1.2323,2))print(&quot;---------------我是华丽的分割线---------------&quot;)#slice(2,5)切片slice(2,5)d=range(0,20)print(d[slice(2,5)])#相当于d[2:5]print(&quot;---------------我是华丽的分割线---------------&quot;)#sorted()按照key排序a={6:2,8:9,1:0,4:-2}sorted(a)print(sorted(a.items()))print(a)#按value排序print(sorted(a.items(),key=lambda x:x[1]))print(&quot;---------------我是华丽的分割线---------------&quot;)#zip()拉链:组合在一起类似自然联接向对应的组成元组，所有元组组成zipa=[1,2,3,4,5,6]b=[&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;]for i in zip(a,b):    print(i)print(&quot;---------------我是华丽的分割线---------------&quot;)#只知道字符串如何导入模块import function_test1__import__(&apos;function_test1&apos;)</code></pre>]]></content>
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3.5学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3.5学习（二）</title>
      <link href="/2018/07/12/Python3.5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2018/07/12/Python3.5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><ul><li>列表</li><li>元组</li><li>字符串</li><li>字典</li><li>集合</li><li>文件操作</li><li>字符编码</li></ul><a id="more"></a> <hr><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><pre><code>names = &quot;ZhangYang Guyun Xiangpeng XuLiangChen&quot;#创建列表[]names = [&quot;ZhangYang&quot;,&quot;Guyun&quot;,&quot;XiangPeng&quot;,&quot;XuLiangchen&quot;]</code></pre><h2 id="1-增删改查"><a href="#1-增删改查" class="headerlink" title="1. 增删改查"></a>1. 增删改查</h2><p>增</p><pre><code>#追加到最后 list.appendnames.append(&quot;LeiHaidong&quot;)#插入到所选位置之前 list.insert(numb,str)names.insert(1,&quot;ChenRonghua&quot;)names.insert(3,&quot;XinZhiyu&quot;)</code></pre><p>删</p><pre><code>#delete1 list.remove(str)names.remove(&quot;ChenRonghua&quot;)#delete2 del list[numb]del names[1]#delete3 list.pop()names.pop() #删除最后一个</code></pre><p>改</p><pre><code>#修改 list[numb]=strnames[2]=&quot;XieDi&quot;print(names)</code></pre><p>查</p><pre><code>#查找 list.index(str)返回位置print(names.index(&quot;XieDi&quot;))</code></pre><h2 id="2-切片"><a href="#2-切片" class="headerlink" title="2. 切片"></a>2. 切片</h2><pre><code>names=[&apos;张三&apos;,&apos;Guyun&apos;,&apos;Xiangpeng&apos;,&apos;Alex&apos;]print(names[1:2])&apos;&apos;&apos;[a:b]取值为[a,b)左闭右开区间可以将:理解为省略的都取显示结果[&apos;Guyun&apos;]&apos;&apos;&apos;#取最后一个值print(names[-1])#取最后两个值print(names[-1:-3])#错误取法&apos;&apos;&apos;结果为[]应该是自左向右取值&apos;&apos;&apos;print(names[-3:-1])#错误取法&apos;&apos;&apos;结果为[&apos;Guyun&apos;, &apos;XiangPeng&apos;]取不到最后一位&apos;&apos;&apos;print(names[-2:])#正确取法#自前向后取3个print(names[:3])names2=[&apos;张三&apos;,&apos;Alex&apos;,&apos;Guna&apos;]#步长切片list[起:终:步长]print(names[0:-1:2])print(names[::2])</code></pre><h2 id="3-copy"><a href="#3-copy" class="headerlink" title="3. copy"></a>3. copy</h2><pre><code>import copynames = [&quot;ZhangYang&quot;,&quot;Guoyun &quot;,[&quot;jack&quot;,&quot;Anny&quot;]]names2 = names.copy()print(names)print(names2)#copy只复制一级列表，浅copy#names中的二级列表[&quot;jack&quot;,&quot;Anny&quot;]只复制了二级列表的id#当通过names[2][1]修改时，names2中的二级列表也会被修改names[1]=&quot;郭云&quot;names[2][1]=&quot;安妮&quot;print(names)print(names2)#copy.deepcopy:深copy#涉及到二级列表时创建新的列表id并创建二级列表#改变names的二级列表时，不改变names2的内容names3 = copy.deepcopy(names)names[2][1]=&quot;anny&quot;print(names)print(names3)for i in names:    print(i)</code></pre><h2 id="4-其他操作"><a href="#4-其他操作" class="headerlink" title="4. 其他操作"></a>4. 其他操作</h2><pre><code>#提取 list[list.index(str)]print(names[names.index(&quot;XieDi&quot;)])#统计重复的 list.count(str)print(names.count(&quot;XieDi&quot;))#清空 list.clear()names.clear()#反转 list.reverse()names.reverse()print(names)#按ascII码排序 list.sort()names.sort() #合并列表 list1.extend(list2),在末尾追加，不合并重复names.extend(names2)#del names2删除列表变量</code></pre><hr><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>元组不希望被修改，且只有两种用法：</p><pre><code>names = (&apos;alex&apos;,&apos;jack&apos;)#index:查找,count:计数print(names.index(&apos;alex&apos;),names.count(&apos;jack&apos;))</code></pre><hr><h1 id="实例一：购物车"><a href="#实例一：购物车" class="headerlink" title="实例一：购物车"></a>实例一：购物车</h1><p>需求：</p><ol><li>启动程序后，让用户输入工资，然后打印商品列表</li><li>允许用户根据商品编号购买商品</li><li>用户选择商品后，检测余额是否够，够就直接扣款，不够就提醒</li><li>可随时退出，退出时，打印已购买的商品和余额</li></ol><p>自己写的代码如下：</p><pre><code># Author:ZT#创建商品列表goods = [[1,&quot;红米Note5&quot;,1099],         [2,&quot;华为荣耀畅玩7c&quot;,899],         [3,&quot;洁柔抽纸&quot;,43],         [4,&quot;小熊面包机&quot;,199],         [5,&quot;小米体脂称&quot;,179]]shoppingcart = [&quot;购物清单为：&quot;]#输入薪水balance = int(input(&quot;薪水：&quot;))#进入循环打印商品列表while balance&gt;0:    for i in goods:        print(i)    numbers =input(&quot;想买哪个?&quot;)    if (numbers!=&apos;q&apos;)and(1&lt;=int(numbers)&lt;=5):        if balance&gt;=goods[int(numbers)-1][2]:            shoppingcart.append(goods[int(numbers)-1])            balance=balance-goods[int(numbers)-1][2]            print(&quot;添加%s到购物车成功！余额为：%d&quot;%(goods[int(numbers)-1][1],balance))        else:            print(&quot;余额不足！！！&quot;)    else:        for i in shoppingcart:            print(i)        print(&quot;余额为：%d&quot;%balance)        break</code></pre><p>Alex代码为:</p><pre><code># Author:Alexproduct_list = [    (&apos;Iphone&apos;,5800),    (&apos;Mac Pro&apos;,9800),    (&apos;Bike&apos;,800),    (&apos;Watch&apos;,10600),    (&apos;Coffee&apos;,31),    (&apos;Python&apos;,120)]shopping_list = []salary = input(&quot;Input your salary:&quot;)#判断输入的数据类型if salary.isdigit():    salary = int(salary)    while True:        &apos;&apos;&apos;        for item in product_list:            print(product_list.index(item),item)        &apos;&apos;&apos;        #enumerate():将列表下标取出        for index,item in enumerate(product_list):            print(index,item)        user_choice = input(&quot;选择要买的商品&gt;&gt;&gt;:&quot;)        #判断输入的数据类型        if user_choice.isdigit():            user_choice: int = int(user_choice)            if user_choice &lt;len(product_list) and user_choice &gt;= 0:                p_item = product_list[user_choice]                if salary&gt;=p_item[1]:                    shopping_list.append(p_item)                    salary -=p_item[1]                    print(&quot;Added %s into shopping cart,your current balance is \033[31;1m%s\033[0m&quot;%(p_item[0],salary))                else:                    print(&quot;\033[41;1m余额只剩%s啦，还买个毛线\033[0m&quot; % salary)            else:                print(&quot;product code %s is not exist&quot;%user_choice)        elif user_choice == &apos;q&apos;:            print(&quot;------Shopping List------&quot;)            for index,p in enumerate(shopping_list):                print(index,p)            print(&quot;Your current balance:&quot;,salary)            exit()        else:            print(&quot;invalid option&quot;)else:    print(&quot;error:please input digit!!&quot;)</code></pre><hr><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><pre><code>name = &quot;zhangsan,my name is {name},and I&apos;m {year} years old&quot;#将字符串首字母大写print(name.capitalize())#统计指定字符出现次数print(name.count(&quot;a&quot;))#name居中，一共打印50个字符，不足用-补充print(name.center(50,&quot;-&quot;))#判断是否以...结尾print(name.endswith(&quot;an&quot;))#find:查找字符串中第一次出现指定字符的位置#[:]字符串切片print(name[name.find(&quot;a&quot;):7])#format:格式化，映射方式传递#format_map:后面使用字典传递print(name.format(name=&quot;Alex&quot;,year=23))print(name.format_map({&apos;name&apos;:&apos;zhangsan&apos;,&apos;year&apos;:&apos;20&apos;}))#判断是否为整数print(&apos;354&apos;.isdigit())#使用指定连字符将列表中元素连接 连字符.join(list)print(&apos;+&apos;.join([&apos;1&apos;,&apos;2&apos;,&apos;3&apos;]))#从左边开始70个字符，不足用*补充print( name.ljust(70,&apos;*&apos;) )#从右侧开始70个字符，不足用-补充print(name.rjust(70,&apos;-&apos;))#strip()去除两边的空格和回车，lstrip()去除左面的空格和回车print(&apos;\nZhangsan&apos;.lstrip())#将预设的对应转换关系在新字符串中相对应，形成字典 p=str.maketrans(&quot;abcdef&quot;,&apos;123456&apos;)#使用translate将字典应用于新的字符串print(&quot;zhangsan&quot;.translate(p))#replace(&apos;oldstr&apos;,&apos;newstr&apos;,times)#将oldstr替换为newstr，从左到右替换times次print(&apos;zhangsan&apos;.replace(&apos;z&apos;,&apos;Z&apos;,1))#将指定字符作为分割符分割字符串形成列表print(&apos;zhangsan&apos;.split(&apos;a&apos;))</code></pre><hr><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="1-创建字典"><a href="#1-创建字典" class="headerlink" title="1. 创建字典"></a>1. 创建字典</h2><pre><code>#字典：key-valueinfo = {    &apos;stu1101&apos;:&quot;Zhang San&quot;,    &apos;stu1102&apos;:&quot;Li Si&quot;,    &apos;stu1103&apos;:&quot;Wang Wu&quot;}#print 无序，没有下标print(info)print(info[&quot;stu1101&quot;])</code></pre><h2 id="2-增加"><a href="#2-增加" class="headerlink" title="2. 增加"></a>2. 增加</h2><pre><code>#info[&quot;key&quot;]=valueinfo[&quot;stu1104&quot;]=&quot;Liu Xin&quot;</code></pre><h2 id="3-修改"><a href="#3-修改" class="headerlink" title="3. 修改"></a>3. 修改</h2><pre><code>#修改指定key的value值info[&quot;stu1101&quot;]=&quot;张三&quot;info[&quot;stu1104&quot;]=&quot;赵六&quot;#updateb = {    &apos;stu1102&apos;:&quot;陈10&quot;,    1:3,    2:4}info.update(b)print(info)</code></pre><h2 id="4-删除"><a href="#4-删除" class="headerlink" title="4. 删除"></a>4. 删除</h2><pre><code>#删除:del与popdel info[&quot;stu1101&quot;]info.pop(&quot;stu1101&quot;)</code></pre><h2 id="5-查询"><a href="#5-查询" class="headerlink" title="5. 查询"></a>5. 查询</h2><pre><code>#py3判断字典里有没有这个key,返回True or Falseprint(info.get(&apos;stu1101&apos;))print(&apos;stu1103&apos; in info)#py2里为#info.has_key(&quot;1103&quot;)print(info)#多级字典嵌套</code></pre><h2 id="6-其他操作"><a href="#6-其他操作" class="headerlink" title="6. 其他操作"></a>6. 其他操作</h2><pre><code>#打印所有的valuesprint(info.values())#打印所有的keysprint(info.keys())#setdefault:先在字典里取值，如果能取到不做更改，取不到则改为目标值info.setdefault(&quot;stu1103&quot;,&quot;胡八&quot;)print(info)#字典转列表print(info.items())#初始化字典c= dict.fromkeys([6,7,8],&quot;test&quot;)print(c)for i in info:    print(i,info[i])#将info转换成了列表，加大了工作量，当字典体积大的时候体现明显for k,v in info.items():    print(k,v)</code></pre><hr><h1 id="实例二：三级菜单"><a href="#实例二：三级菜单" class="headerlink" title="实例二：三级菜单"></a>实例二：三级菜单</h1><p>主要依靠多级字典实现</p><pre><code># Author:ZTcity_map = {    &quot;辽宁省&quot;:{        &quot;沈阳市&quot;:{            &quot;铁西区&quot;:[&quot;居住&quot;,&quot;My home&quot;],            &quot;和平区&quot;:[&quot;学校&quot;,&quot;My school&quot;]        },        &quot;大连市&quot;:{            &quot;中山区&quot;:[&quot;游玩&quot;,&quot;My travel&quot;],            &quot;沙河口区&quot;:[&quot;旅店&quot;,&quot;My hotel&quot;]        },        &quot;丹东市&quot;:{            &quot;元宝区&quot;:[&quot;断桥&quot;,&quot;happy!!&quot;]        }    },    &quot;内蒙古省&quot;:{        &quot;呼伦贝尔市&quot;:{            &quot;海拉尔&quot;:[&quot;森林公园&quot;,&quot;鸟园&quot;],            &quot;拉布大林&quot;:[&quot;工作&quot;,&quot;大酒店&quot;]        },    },    &quot;黑龙江省&quot;:{        &quot;大庆市&quot;:{            &quot;龙凤区&quot;:[&quot;路过&quot;,&quot;姥姥&quot;]        }    }}#设置了一个控制循环的变量exit_mark= Truewhile exit_mark:    #只打印出city_map中的key    for i in city_map:        print(i)    choice = input(&quot;选择进入&gt;&gt;&gt;:&quot;)    if choice in city_map:        while exit_mark:            for i2 in city_map[choice]:                print(&quot;\t&quot;,i2)            choice2 = input(&quot;选择进入&gt;&gt;&gt;:&quot;)            if choice2 in city_map[choice]:                while exit_mark:                    for i3 in city_map[choice][choice2]:                        print(&quot;\t\t&quot;,i3)                    choice3 = input(&quot;选择进入&gt;&gt;&gt;:&quot;)                    if choice3 in city_map[choice][choice2]:                        for i4 in city_map[choice][choice2][choice3]:                            print(&quot;\t\t\t&quot;,i4)                        choice4 = input(&quot;最后一层，按b返回上一级&quot;)                        if choice4 == &quot;b&quot;:                            pass                        elif choice4 ==&quot;q&quot;:                            exit_mark = False                    if choice3 == &quot;b&quot;:                        break                    elif choice3 ==&quot;q&quot;:                        exit_mark = False            if choice2 == &quot;b&quot;:                break            elif choice2 == &quot;q&quot;:                exit_mark = False</code></pre><hr><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合重要的两个作用：</p><ol><li>去重</li><li>关系测试</li></ol><p>集合是无序的</p><h2 id="1-集合的创建"><a href="#1-集合的创建" class="headerlink" title="1. 集合的创建"></a>1. 集合的创建</h2><pre><code>#集合的创建#通过set(list)创建list_1 = [1,4,5,7,3,6,7,9]list_1 = set(list_1)#通过set([])创建list_2 =set([2,6,0,66,22,8,4])print(list_1,list_2)</code></pre><h2 id="2-集合运算"><a href="#2-集合运算" class="headerlink" title="2. 集合运算"></a>2. 集合运算</h2><pre><code>#取交集interlist_1=list_1.intersection(list_2)print(interlist_1)#取并集unionlist_1 = list_1.union(list_2)print(unionlist_1)#差集diflist_1 = list_1.difference(list_2)print(diflist_1)#子集、父集#A.issubset(B):判断A是否为B的子集，返回True or False#A.issuperset(B):判断A是否为B的父集，返回True or Falselist_3 = set([1,3,7])print(list_3.issubset(list_1))print(list_1.issuperset(list_3))#对称差集print(list_1.symmetric_difference(list_2))&quot;&quot;&quot;符号表示交集 &amp;并集 |差集 -对称差集 ^&quot;&quot;&quot;</code></pre><h2 id="3-集合的增删改查"><a href="#3-集合的增删改查" class="headerlink" title="3. 集合的增删改查"></a>3. 集合的增删改查</h2><pre><code>#add()增加元素#update(list)增加列表list_1.add(999)list_1.update([888,777])print(list_1)#pop随机删除并返回删除的值print(list_1.pop())#discard:删除指定元素list_1.discard(4)print(list_1)#查询inYorN = 1 in list_1print(YorN)</code></pre><hr><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>现有一文件实例yesterday.txt：</p><pre><code>Oh, yesterday when I was young噢 昨日当我年少轻狂So many, many songs were waiting to be sung有那么那么多甜美的曲儿等我歌唱So many wild pleasures lay in store for me有那么多肆意的快乐And so much pain my eyes refused to see还有那么多痛苦 我的双眼却视而不见There are so many songs in me that won&apos;t be sung我有太多歌曲永远不会被唱起I feel the bitter taste of tears upon my tongue我尝到了舌尖泪水的苦涩滋味The time has come for me to pay for yesterday终于到了付出代价的时间 为了昨日When I was young当我年少轻狂</code></pre><h2 id="1-打开"><a href="#1-打开" class="headerlink" title="1. 打开"></a>1. 打开</h2><pre><code>#open(&quot;filename&quot;,打开方式,encoding=&quot;编码格式&quot;)f = open(&quot;yesterday&quot;,encoding=&quot;utf-8&quot;)#f:文件句柄&apos;&apos;&apos;with语句避免打开文件后忘记关闭通过上下文管理\下一行缩进表示清晰，省的一行字太多&apos;&apos;&apos;#with open(&quot;file_name&quot;,打开方式,encoding=编码方式) as 句柄名with open(&quot;yesterday&quot;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f,\        open(&quot;yesterday.bak&quot;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f_new:    for line in f:        print(line)    print(&quot;------------------&quot;)    for line in f_new:        print(line)</code></pre><h2 id="2-读"><a href="#2-读" class="headerlink" title="2. 读"></a>2. 读</h2><pre><code>data = f.read()#光标移动到了最后一行print(data)data2 =f.read()print(&quot;---------data2--------&quot;,data2)#结果中data2无内容，read读完后光标停留到最后#r+追加读写光标在最后，先读再以追加模式写入f= open(&quot;yesterday2&quot;,&apos;r+&apos;,encoding=&apos;utf-8&apos;)</code></pre><h2 id="3-写"><a href="#3-写" class="headerlink" title="3. 写"></a>3. 写</h2><pre><code>#w = write创建一个文件#a = append追加写不能读#创建了yesterday2并写入f = open(&quot;yesterday2&quot;,&apos;a&apos;,encoding=&quot;utf-8&quot;)f.write(&quot;\n我爱北京天安门。。。\n&quot;)f.write(&quot;天安门上太阳升。。。&quot;)f.close()#w+写读先创建再读f= open(&quot;yesterday2&quot;,&apos;w+&apos;,encoding=&apos;utf-8&apos;)</code></pre><h2 id="4-修改"><a href="#4-修改" class="headerlink" title="4. 修改"></a>4. 修改</h2><pre><code># Author:ZT&quot;&quot;&quot;文件不能直接在硬盘上修改有两种修改方式第一种是在内存中修改，然后写回硬盘(内容大的时候不方便，一般不采用)另一种是修改后写入新文件&quot;&quot;&quot;f = open(&quot;yesterday&quot;,&apos;r&apos;,encoding=&apos;utf-8&apos;)f_new = open(&quot;yesterday.bak&quot;,&apos;w&apos;,encoding=&apos;utf-8&apos;)for line in f:    if &quot;肆意的快乐&quot; in line:        #详见字符串的replace功能        line = line.replace(&quot;肆意的快乐&quot;,&quot;来啊快活啊&quot;)    f_new.write(line)f.close()f_new.close()</code></pre><h2 id="5-例子"><a href="#5-例子" class="headerlink" title="5. 例子"></a>5. 例子</h2><pre><code>#high loop 高效#实现创建将第十行的句子替换为----continue-----f = open(&quot;yesterday&quot;,&apos;r&apos;,encoding=&apos;utf-8&apos;)count = 0for line in f:    if count ==9:        print(&apos;--------continue--------&apos;)        count+=1        continue    count += 1    #读文件的时候换行符\n也被读进去，在逐行打印中去掉    print(line.strip())f.close()#low loop 低效#实现第十行句子替换为-------end------#f.readlines:以字符串形式读入#当文件很大时特别占用内存f = open(&quot;yesterday&quot;,&apos;r&apos;,encoding=&apos;utf-8&apos;)for index,line in enumerate(f.readlines()):    if index == 9:        print(&apos;-------end------&apos;)        continue    print(line.strip())</code></pre><h2 id="6-tell、seek"><a href="#6-tell、seek" class="headerlink" title="6. tell、seek"></a>6. tell、seek</h2><pre><code>f = open(&quot;yesterday&quot;,&apos;r&apos;,encoding=&apos;utf-8&apos;)#返回指针位置，目前处在文件头print(f.tell())print(f.readline())#返回指针位置，目前处在第一行末尾print(f.tell())#设置指针指向文件头f.seek(0)print(f.tell())print(f.readline())</code></pre><h2 id="7-其他功能"><a href="#7-其他功能" class="headerlink" title="7. 其他功能"></a>7. 其他功能</h2><pre><code>#encoding:打印文件编码print(f.encoding)#isatty:显示终端设备print(f.isatty())#截断，从第n个字符后全部舍弃默认为0f.truncate(10)#flush()#正常输出需要等缓存区满了后,flush可以及时写入，可以制作进度条效果print(f.flush())f.close()</code></pre><h2 id="8-制作进度条"><a href="#8-制作进度条" class="headerlink" title="8. 制作进度条"></a>8. 制作进度条</h2><pre><code>#利用flush强制刷新功能#正常文件需要等到循环结束才能显示，使用flush可以及时刷到硬盘中# Author:ZTimport sys,timefor i in range(20):    sys.stdout.write(&quot;#&quot;)    sys.stdout.flush()    time.sleep(0.5)</code></pre><hr><h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p><img src="/images/字符编码转化图.jpg" alt="字符编码转换图"></p><p>当编译语言使用系统默认编码(uft-8)时：</p><pre><code># Author:ZT&apos;&apos;&apos;py程序代码的默认编码是utf-8py字符串是以unicode编码的encode()默认采用系统编码将Unicode编码成utf-8encode(&quot;gbk&quot;)编码成gbk&apos;&apos;&apos;import sys#打印出系统的默认编码print(sys.getdefaultencoding())s=&quot;哈哈&quot;#将Unicode编码成gbks_gbk = s.encode(&quot;gbk&quot;)print(s_gbk)print(s.encode())#将gbk转换成utf-8#先解码成unicode,再编码成utf-8gbk_utf8 = s_gbk.decode(&quot;gbk&quot;).encode(&quot;utf-8&quot;)print(gbk_utf8)</code></pre><p>当编译语言使用gbk编码时：</p><pre><code>#将编译语言设置为gbk编码#-*-coding:gbk-*-# Author:ZT&quot;&quot;&quot;python3中进行encode时自动转换成byte类型&quot;&quot;&quot;import sys#获取系统默认编码print(sys.getdefaultencoding())#保存到字符串的时候依旧是unicode编码s=&quot;你好&quot;#编码成gbkprint(s.encode(&quot;gbk&quot;))print(s.encode(&quot;utf-8&quot;).decode(&quot;utf-8&quot;).encode(&quot;gb2312&quot;))#编码成utf-8-&gt;解码-&gt;编码成gb2312-&gt;解码，最终为unicodeprint(s.encode(&quot;utf-8&quot;).decode(&quot;utf-8&quot;).encode(&quot;gb2312&quot;).decode(&quot;gb2312&quot;))</code></pre><hr><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h2 id="作业一-优化购物车"><a href="#作业一-优化购物车" class="headerlink" title="作业一:优化购物车"></a>作业一:优化购物车</h2><p>需求：</p><p>用户入口：</p><ol><li>商品信息存在文件中</li><li>记录已购商品，余额记录（仅第一登录时输入余额）。</li></ol><p>商家入口：</p><ol><li>可以添加商品，修改商品价格。</li></ol><p>不采用函数：</p><p>商家入口：</p><pre><code># Author:ZT# 先打开商品文件f = open(&apos;business.txt&apos;, &apos;r&apos;,encoding=&apos;utf-8&apos;)# 创建商品列表commodity_list = []# 将文件中的字符串按照列表的形式读入for item in f:    commodity_list.append(item.strip())f.close()#设置全局退出变量exit_mark = Truewhile exit_mark:    adOrmo = input(&quot;您需要什么操作：增a,删d,改m,显v,返回b，离开q&quot;)    while exit_mark:        if adOrmo ==&apos;v&apos;:            for item in commodity_list:                print(item)            break        elif adOrmo == &apos;a&apos;:            commodity = input(&quot;请输入商品：&quot;)            if commodity ==&quot;q&quot;:                exit_mark = False            elif commodity ==&quot;b&quot;:                break            else:                price = input(&quot;请输入价格：&quot;)                if price ==&quot;q&quot;:                    exit_mark = False                elif price ==&quot;b&quot;:                    break                elif price.isdigit():                    # 先打开商品文件                    f = open(&apos;business.txt&apos;, &apos;a+&apos;,encoding=&apos;utf-8&apos;)                    # 如果不是新文件需要先换行                    if f.tell() != 0:                        print(&apos;\n&apos;)                    #在末行追加上商品                    f.write(commodity+&apos;\t&apos;+price+&apos;\n&apos;)                    #在列表中添加商品                    f.close()                    commodity_list.append(commodity+&apos;\t&apos;+price)                    print(&quot;成功将%s添加到商品列表！！&quot;%commodity)                    for index,item in enumerate(commodity_list):                        print(index,item)                    break                else:                    print(&quot;输入金额不合法！！！&quot;)                    break        elif adOrmo == &apos;m&apos;:            for index,item in enumerate(commodity_list):                print(index,item)            user_choice = input(&quot;需要修改哪个：&quot;)            if user_choice ==&quot;q&quot;:                exit_mark = False            elif user_choice ==&quot;b&quot;:                break            elif int(user_choice)&gt;=0 and int(user_choice)&lt;len(commodity_list):                user_mo =input(&quot;修改为：&quot;)                if user_mo == &quot;q&quot;:                    exit_mark = False                elif user_mo == &quot;b&quot;:                    break                elif user_mo.isdigit():                    commoditymo = commodity_list[int(user_choice)].split(&apos;\t&apos;)                    commodity_list[int(user_choice)] =commoditymo[0]+&apos;\t&apos;+user_mo                    f = open(&apos;business.txt&apos;, &apos;w&apos;,encoding=&apos;utf-8&apos;)                    for item in commodity_list:                        f.write(item+&apos;\n&apos;)                    f.close()                    print(&quot;结果为：&quot;)                    for index,item in enumerate(commodity_list):                        print(index,item)                    break                else:                    print(&quot;输入金额不合法！！&quot;)                    break            else:                print(&quot;查找不到该商品！！&quot;)                break        elif adOrmo == &apos;d&apos;:            for index,item in enumerate(commodity_list):                print(index,item)            user_choice = input(&quot;需要删除哪个：&quot;)            if user_choice ==&quot;q&quot;:                exit_mark = False            elif user_choice ==&quot;b&quot;:                break            elif int(user_choice)&gt;=0 and int(user_choice)&lt;len(commodity_list):                del commodity_list[int(user_choice)]                f = open(&apos;business.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;)                for item in commodity_list:                    f.write(item+&apos;\n&apos;)                f.close()                print(&quot;结果为：&quot;)                for item in commodity_list:                    print(item)                break            else:                print(&quot;查找不到该商品！！&quot;)                break        elif adOrmo ==&quot;b&quot;:            break        elif adOrmo ==&quot;q&quot;:            print(&quot;再见！！&quot;)            exit_mark = False        else:            print(&quot;输入参数不合法!!&quot;)            break</code></pre><p>用户入口：</p><pre><code># Author:ZT#创建用户列表custom_list =[]#打开用户文件f_custom = open(&apos;custom.txt&apos;,&apos;a+&apos;,encoding=&apos;utf-8&apos;)#判断用户文件是否为空isFirst = f_custom.tell()if isFirst == 0:    while True:        salary = input(&apos;首次登陆，请输入工资:&apos;)        if salary.isdigit():            f_custom.write(&quot;salary&quot;+&apos;\t&apos;+salary)            break        else:            print(&quot;输入格式不正确&quot;)else:    passf_custom.seek(0)balance_line=f_custom.readline().split(&apos;\t&apos;)balance = balance_line[1].strip()for line in f_custom:    custom_list.append(line.strip())f_custom.close()print(&quot;您的余额为：%s&quot;%balance)# 先打开商品文件f = open(&apos;business.txt&apos;, &apos;r&apos;,encoding=&apos;utf-8&apos;)# 创建商品列表commodity_list = []# 将文件中的字符串按照列表的形式读入for line in f:    commodity_list.append(line.strip())f.close()#用户选择界面exit_mark =Truewhile exit_mark:    user_choose = input(&quot;请问您需要什么服务：购买商品(m),查询已购商品(c),余额(y),返回上一级(b),退出(q)&quot;)    if user_choose == &apos;m&apos;:        while exit_mark:            # 打印商品列表            for index, item2 in enumerate(commodity_list):                print(index, item2)            #用户选择            user_buy = input(&quot;请选择一个商品：&quot;)            #判断输入是否正确            if int(user_buy) &gt;=0 and int(user_buy) &lt;len(commodity_list):                price = int(commodity_list[int(user_buy)].split(&apos;\t&apos;)[1])                if int(balance) &gt;= price:                    balance = str(int(balance)-price)                    custom_list.append(commodity_list[int(user_buy)])                    f_custom = open(&apos;custom.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;)                    f_custom.write(&apos;balance&apos;+&apos;\t&apos;+balance)                    for item in custom_list:                        f_custom.write(&apos;\n&apos;+item)                    f_custom.close()                    for item in custom_list:                        print(item)                    print(&quot;添加%s到购物车成功！！&quot;%commodity_list[int(user_buy)].split(&apos;\t&apos;)[0])                    isBuy = input(&quot;是否继续购买？y/n&quot;)                    if isBuy == &apos;n&apos;:                        break                    else:                        pass                else:                    print(&quot;抱歉您的余额不足，为%s&quot;%balance)                    break            elif user_buy == &apos;b&apos;:                break            elif user_buy ==&apos;q&apos;:                print(&quot;欢迎下次光临！！&quot;)                exit_mark =False            else:                print(&quot;非法输入！！！&quot;)                exit_mark = False    elif user_choose ==&apos;c&apos;:        print(&quot;您购买了以下商品：&quot;)        for index,item in enumerate(custom_list):            print(index,item)    elif user_choose ==&apos;y&apos;:        print(&quot;您的余额为：%s&quot;%balance)    elif user_choose ==&apos;b&apos;:        pass    elif user_choose ==&apos;q&apos;:        print(&quot;欢迎下次光临，再见！！&quot;)        break    else:        print(&quot;非法输入&quot;)        exit_mark =False</code></pre><p>采用函数：</p><p>商家接口：</p><pre><code># Author:ZT#将文件按照列表形式读入def ftolist(list):    with open (&quot;business.txt&quot;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f:        for line in f:            list.append(line.strip())#带编号显示列表：def showlistn(list):    for index,item in enumerate(list):        print(index,item)#无编号显示列表：def showlist(list):    for item in list:        print(item)#追加商品def appenditem(commodity,price):    with open (&apos;business.txt&apos;,&apos;a+&apos;,encoding=&apos;utf-8&apos;) as f:        if f.tell() != 0:            print(&apos;\n&apos;)        f.write(commodity+&apos;\t&apos;+price)#分割字符串def splitstr(s):    list=s.split(&apos;\t&apos;)    return list#修改文件def modifyf(list):    with open (&apos;business.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f:        for item in list:            f.write(item+&apos;\n&apos;)#创建商品列表commodity_list = []#调用ftolist()将文件读入列表ftolist(commodity_list)#设置全局退出变量exit_mark = Truewhile exit_mark:    adOrmo = input(&quot;您需要什么操作：增a,删d,改m,显v,返回b，离开q&quot;)    while exit_mark:        if adOrmo ==&apos;v&apos;:            showlist(commodity_list)            break        elif adOrmo == &apos;a&apos;:            commodity = input(&quot;请输入商品：&quot;)            if commodity ==&quot;q&quot;:                exit_mark = False            elif commodity ==&quot;b&quot;:                break            else:                price = input(&quot;请输入价格：&quot;)                if price ==&quot;q&quot;:                    exit_mark = False                elif price ==&quot;b&quot;:                    break                elif price.isdigit():                    # 追加到文件中                    appenditem(commodity,price)                    commodity_list.append(commodity+&apos;\t&apos;+price)                    print(&quot;成功将%s添加到商品列表！！&quot;%commodity)                    showlistn(commodity_list)                    break                else:                    print(&quot;输入金额不合法！！！&quot;)                    break        elif adOrmo == &apos;m&apos;:            showlistn(commodity_list)            user_choice = input(&quot;需要修改哪个：&quot;)            if user_choice ==&quot;q&quot;:                exit_mark = False            elif user_choice ==&quot;b&quot;:                break            elif int(user_choice)&gt;=0 and int(user_choice)&lt;len(commodity_list):                user_mo =input(&quot;修改为：&quot;)                if user_mo == &quot;q&quot;:                    exit_mark = False                elif user_mo == &quot;b&quot;:                    break                elif user_mo.isdigit():                    commodity_list[int(user_choice)] =splitstr(commodity_list[int(user_choice)])[0]+&apos;\t&apos;+user_mo                    modifyf(commodity_list)                    print(&quot;结果为：&quot;)                    showlistn(commodity_list)                    break                else:                    print(&quot;输入金额不合法！！&quot;)                    break            else:                print(&quot;查找不到该商品！！&quot;)                break        elif adOrmo == &apos;d&apos;:            showlistn(commodity_list)            user_choice = input(&quot;需要删除哪个：&quot;)            if user_choice ==&quot;q&quot;:                exit_mark = False            elif user_choice ==&quot;b&quot;:                break            elif int(user_choice)&gt;=0 and int(user_choice)&lt;len(commodity_list):                del commodity_list[int(user_choice)]                modifyf(commodity_list)                print(&quot;结果为：&quot;)                showlist(commodity_list)                break            else:                print(&quot;查找不到该商品！！&quot;)                break        elif adOrmo ==&quot;b&quot;:            break        elif adOrmo ==&quot;q&quot;:            print(&quot;再见！！&quot;)            exit_mark = False        else:            print(&quot;输入参数不合法!!&quot;)            break</code></pre><p>用户接口：</p><pre><code># Author:ZT#拆分字符串def splitstr(s):    list=s.split(&apos;\t&apos;)    return list#判断是否为空文件def isNull():    with open(&apos;custom.txt&apos;, &apos;a+&apos;, encoding=&apos;utf-8&apos;) as f_custom:        isFirst = f_custom.tell()        if isFirst == 0:            while True:                salary = input(&apos;首次登陆，请输入工资:&apos;)                if salary.isdigit():                    f_custom.write(&quot;salary&quot; + &apos;\t&apos; + salary)                    break                else:                    print(&quot;输入格式不正确&quot;)#f读入def readf(list,f):    for line in f:        list.append(line.strip())#显示列表：def showlist(list):    for index, item in enumerate(list):        print(index, item)#读取custom文件中的内容def ftoclist(custom_list):    with open(&apos;custom.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f_custom:        #balance_line =f_custom.readline().split(&apos;\t&apos;)        balance =splitstr(f_custom.readline())[1].strip()#balance_line[1].strip()        readf(custom_list,f_custom)    return custom_list,balance#写回custom文件内容def clisttof(custom_list,balance):    with open(&apos;custom.txt&apos;, &apos;w&apos;, encoding=&apos;utf-8&apos;) as f_custom:        f_custom.write(&apos;balance&apos; + &apos;\t&apos; + balance)        for item in custom_list:            f_custom.write(&apos;\n&apos; + item)#读取business文件内容def ftoblist(commodity_list):    with open(&apos;business.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f_commodity:        readf(commodity_list,f_commodity)#打印商品余额def print_ba(balance):    print(&quot;您的余额为：%s&quot;%balance)#其他输入处理def ill():    print(&quot;非法输入！！&quot;)def quit():    print(&quot;欢迎下次光临！！&quot;)    return False#创建用户列表custom_list =[]# 创建商品列表commodity_list = []#调用isNull判断用户文件是否为空isNull()#调用ftolist()将用户文件读到列表中balance =ftoclist(custom_list)[1]#打印用户余额print_ba(balance)# 调用ftoblish()将商品文件读入列表ftoblist(commodity_list)#用户选择界面exit_mark =Truewhile exit_mark:    user_choose = input(&quot;请问您需要什么服务：购买商品(m),查询已购商品(c),余额(y),返回上一级(b),退出(q)&quot;)    if user_choose == &apos;m&apos;:        while exit_mark:            # 打印商品列表            showlist(commodity_list)            #用户选择            user_buy = input(&quot;请选择一个商品：&quot;)            #判断输入是否正确            if int(user_buy) &gt;=0 and int(user_buy) &lt;len(commodity_list):                price = splitstr(commodity_list[int(user_buy)])[1].strip()                if int(balance) &gt;= int(price):                    balance = str(int(balance)-int(price))                    custom_list.append(commodity_list[int(user_buy)])                    #调用clisttof写回文件                    clisttof(custom_list,balance)                    #显示列表                    showlist(custom_list)                    print(&quot;添加%s到购物车成功！！&quot;%splitstr(commodity_list[int(user_buy)])[0])                    isBuy = input(&quot;是否继续购买？y/n&quot;)                    if isBuy == &apos;n&apos;:                        break                    else:                        pass                else:                    print(&quot;抱歉您的余额不足，为%s&quot;%balance)                    break            elif user_buy == &apos;b&apos;:                break            elif user_buy ==&apos;q&apos;:                exit_mark =quit()            else:                ill()    elif user_choose ==&apos;c&apos;:        print(&quot;您购买了以下商品：&quot;)        #调用showlist显示列表        showlist(custom_list)    elif user_choose ==&apos;y&apos;:        print_ba(balance)    elif user_choose ==&apos;b&apos;:        pass    elif user_choose ==&apos;q&apos;:        exit_mark = quit()    else:        ill()</code></pre><h2 id="作业二"><a href="#作业二" class="headerlink" title="作业二"></a>作业二</h2><p>实现shell sed替换功能</p><pre><code># Author:ZT#打印列表def printf():    with open(&apos;sed&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f:        for line in f:            print(line.strip())#打开文件读入列表def openf(list):    with open(&apos;sed&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f:        for line in f:            list.append(line.strip())#将列表写入文件def writef(list):    with open(&apos;sed&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f:        for item in list:            f.write(item+&apos;\n&apos;)#替第n换行def sedln(n,str,sedlist):    n -= 1    sedlist[n]=str    writef(sedlist)#替换字符串def replacestr(str_old,str_new,sedlist):    #使用index修改列表中的元素    for index,line in enumerate(sedlist):        if str_old in line:            sedlist[index]=line.replace(str_old,str_new)    writef(sedlist)sedlist=[]openf(sedlist)n=input(&quot;想替换哪行&quot;)str=input(&apos;想替换呈什么&apos;)sedln(int(n),str,sedlist)printf()str_old=input(&quot;想替换什么字符&quot;)str_new=input(&quot;替换成什么&quot;)replacestr(str_old,str_new,sedlist)printf()</code></pre><h2 id="作业三：修改haproxy配置文件"><a href="#作业三：修改haproxy配置文件" class="headerlink" title="作业三：修改haproxy配置文件"></a>作业三：修改haproxy配置文件</h2><p>需求：</p><pre><code>1.查    输入：www.oldboy.org    获取当前backend下的所有记录2.新建    输入：        arg={            &apos;bakend&apos;:&apos;www.5ifish.me&apos;,            &apos;record&apos;:{                &apos;server&apos;:&apos;100.1.7.9&apos;,                &apos;weight&apos;:20,                &apos;maxconn&apos;:30            }        }3.删除    输入：        arg={            &apos;bakend&apos;:&apos;www.5ifish.me&apos;,            &apos;record&apos;:{                &apos;server&apos;:&apos;100.1.7.9&apos;,                &apos;weight&apos;:20,                &apos;maxconn&apos;:30            }        }</code></pre><p>haproxy文件如下：</p><pre><code>global    log 127.0.0.1 local12    daemon    maxconn 256    log 127.0.0.1 local2 infodefaults    log global    mode http    timeout connect 5000ms    timeout client 50000ms    timeout server 50000ms    option dontlognulllisten stats :8888    stats enable    stats url    /admin    stats auth    admin:1234frontend oldboy.org    bind 0.0.0.0:80    option httplog    option httpclose    option forwardfor    log global    acl www hdr_reg(host) -i www.oldboy.org    use_backend www.oldboy.org if wwwbackend    www.oldboy.org    server    100.1.7.9    100.1.7.9    weight    20    maxconn    3000</code></pre><p>代码如下：</p><pre><code># Author:ZT#非法输入提示def irr():    print(&quot;非法输入！！&quot;)#继续操作提示def nextp():    while True:        Y_or_N =input(&quot;继续操作?(y/n)&quot;)        if Y_or_N == &apos;n&apos;:            return 1        elif Y_or_N == &apos;y&apos;:            return 0        else:            irr()#多行输入（双enter结束）（循环输入，直到输入行为空）def inputln():    print(&quot;请输入操作的条目：&quot;)    str = input()    while True:        str2 =input()        if str2.strip():            str=str+&apos;\n&apos;+str2        else:            break    return str#查询条目函数def user_search(addr):    with open(&apos;haproxy&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f:        for line in f:            if &apos;backend\t&apos;+addr+&apos;\n&apos; in line:                break        for line in f:            if &apos;backend&apos;in line:                break            else:                print(line.strip())#添加条目函数def user_add(code_body):    code_dic = eval(code_body)    #判断是否存在标识符    mark = True    with open(&apos;haproxy&apos;,&apos;a+&apos;,encoding=&apos;utf-8&apos;) as f:        #从头开始读文件        f.seek(0)        for line in f:            if &apos;backend\t&apos;+code_dic[&apos;backend&apos;]+&apos;\n&apos; in line:                print(&quot;该条目已存在，请勿重复添加！！&quot;)                mark=False                break        if mark:            f.write(&apos;\nbackend\t&apos;+code_dic[&apos;backend&apos;]+&apos;\n\tserver\t&apos;\                    +str(code_dic[&apos;record&apos;][&apos;server&apos;])+&apos;\tweight\t&apos;+str(code_dic[&apos;record&apos;][&apos;weight&apos;])\                    +&apos;\tmaxconn\t&apos;+str(code_dic[&apos;record&apos;][&apos;maxconn&apos;]))            print(&apos;添加条目成功！！&apos;)#删除条目函数def user_delete(code_body):    #将字符串编译    code_dic = eval(code_body)    #标识符    mark = True    #备份文件    with open(&apos;haproxy_bak&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f_bak:        with open(&apos;haproxy&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f:            for line in f:                f_bak.write(line)    #改文件    with open(&apos;haproxy_bak&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f_r:        with open(&apos;haproxy&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;) as f_w:            for line in f_r:                if &apos;backend&apos;+&apos;\t&apos;+code_dic[&apos;backend&apos;]+&apos;\n&apos; in line:                    mark = False                    break                else:                    f_w.write(line)            for line in f_r:                if &apos;backend&apos; in line:                    f_w.write(line)                    break            for line in f_r:                f_w.write(line)            if mark:                print(&quot;不存在该条目！！&quot;)            else:                print(&quot;删除成功&quot;)while True:    user_choose = input(&quot;1.search\n2.add\n3.delete\n4.quit请选择一项操作：&quot;)    if int(user_choose) == 1:        user_search(input(&quot;请输入要查找的网址：&quot;))        if nextp():            break    elif int(user_choose) == 2:        user_add(inputln())        if nextp():            break    elif int(user_choose) == 3:        user_delete(inputln())        if nextp():            break    elif user_choose == &apos;q&apos;:        break    else:        irr()</code></pre>]]></content>
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3.5学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>好久没更新啦!</title>
      <link href="/2018/07/12/%E5%A5%BD%E4%B9%85%E6%B2%A1%E6%9B%B4%E6%96%B0%E5%95%A6/"/>
      <url>/2018/07/12/%E5%A5%BD%E4%B9%85%E6%B2%A1%E6%9B%B4%E6%96%B0%E5%95%A6/</url>
      <content type="html"><![CDATA[<p>之前一直在备战软考和六级考试</p><p>导致一直没有学习python</p><p>这几天得努力啦</p>]]></content>
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python3.5学习（一）</title>
      <link href="/2018/04/19/Python3.5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2018/04/19/Python3.5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><h2 id="简单的输入输出"><a href="#简单的输入输出" class="headerlink" title="简单的输入输出"></a>简单的输入输出</h2><pre><code>username = input(&quot;username&quot;)print(username)</code></pre><h2 id="整行打印"><a href="#整行打印" class="headerlink" title="整行打印"></a>整行打印</h2><p>三种方式:</p><a id="more"></a> <pre><code>info1 = &apos;&apos;&apos;----------- info of&apos;&apos;&apos;+ name +&apos;&apos;&apos; ------------Name:&apos;&apos;&apos; + name +&apos;&apos;&apos;Age:&apos;&apos;&apos; + age+&apos;&apos;&apos;Job:&apos;&apos;&apos; + job +&apos;&apos;&apos;Salary:&apos;&apos;&apos; + salary +&apos;&apos;&apos;----------------------------------------------&apos;&apos;&apos;print(info1)</code></pre><p>or</p><pre><code>info2 = &apos;&apos;&apos;------------- info of %s ----------Name:%sAge:%dJob:%sSalary:%s&apos;&apos;&apos; %(name,name,age,job,salary)print(info2)</code></pre><p>or</p><pre><code>info3 = &apos;&apos;&apos;------------ info of {_name}---------Name:{_name}Age:{_age}Job:{_job}Salary:{_salary}&apos;&apos;&apos;.format(    _name=name,    _age=age,    _job=job,    _salary=salary)print(info3)</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><pre><code>name = &quot;zt&quot;name2 = nameprint (&quot;My name is &quot;,name,name2)name  = &quot;PaoChe Ge&quot;gf_of_oldboy = &quot;007&quot;#大写代表常量PIE = 200city = &quot;中国&quot;print(name,name2)print(city)</code></pre><p>输出结果为：</p><pre><code>My name is  zt ztPaoChe Ge zt中国</code></pre><p>可以看出Python的变量赋值和C语言的指针很像，我们将一变量等于(=)另一变量时，是将右侧变量的指向地址赋给左侧变量，而不是将右侧变量的值传递过去。</p><h2 id="getpass模块"><a href="#getpass模块" class="headerlink" title="getpass模块"></a>getpass模块</h2><pre><code>import getpasspassword = getpass.getpass(&quot;password:&quot;)</code></pre><p>无回现输入密码</p><h2 id="if判断语句"><a href="#if判断语句" class="headerlink" title="if判断语句"></a>if判断语句</h2><pre><code>import getpass_username = &quot;ZT&quot;_password = &quot;123123&quot;username = input(&quot;username:&quot;)password = getpass.getpass(&quot;password:&quot;)if _username == username and _password == password:    print(&quot;Welcome user {name}&quot;.format(name = username))else:    print(&quot;Invalid username or password&quot;)print(username,password)</code></pre><p>使用时注意if语句后的”:”容易漏掉</p><h2 id="for循环语句"><a href="#for循环语句" class="headerlink" title="for循环语句"></a>for循环语句</h2><pre><code>for i in range(0,10,3):    print(&quot;loop &quot;,i)</code></pre><p>i=0，判断是否小于10，之后进入循环输出0，循环后i=i+3，<br>i=3，判断是否小于10，之后进入循环输出3，循环后i=i+3，<br>i=6，判断是否小于10，之后进入循环输出6，循环后i=i+3，<br>i=9，判断是否小于10，之后进入循环输出9，循环后i=i+3，<br>i=12，判断是否小于10，循环终止。<br>※先判断，再循环，后自增。</p><h2 id="while循环语句"><a href="#while循环语句" class="headerlink" title="while循环语句"></a>while循环语句</h2><pre><code>i = 0while i&lt;3:    print(i)    i = i + 1</code></pre><h3 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h3><p>continue 跳出本次循环进行下次循环<br>break 退出本循环体</p><h3 id="实例：猜数字"><a href="#实例：猜数字" class="headerlink" title="实例：猜数字"></a>实例：猜数字</h3><pre><code>_myage = 26count = 0while count &lt;3:    myage = int(input(&quot;猜猜我年龄\n&quot;))    if myage == _myage:        print(&quot;恭喜你，猜对了！&quot;)        break    elif myage &gt;_myage:        print(&quot;往小了猜&quot;)    else:        print(&quot;往大了猜&quot;)    count = count +1    if count == 3:        countine_confirm = input(&quot;do you want to keep game?&quot;)        if countine_confirm !=&quot;n&quot;:            count = 0</code></pre><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="登录接口"><a href="#登录接口" class="headerlink" title="登录接口"></a>登录接口</h2><ul><li>输入用户名密码</li><li>认证成功后显示欢迎信息</li><li>输错三次后锁定账户</li></ul><p>难点:</p><ul><li>涉及到Python对文件的操作增删改查</li><li>判断和循环语句的嵌套使用</li></ul><h3 id="Python3-5对文件的操作"><a href="#Python3-5对文件的操作" class="headerlink" title="Python3.5对文件的操作"></a>Python3.5对文件的操作</h3><pre><code>open(‘test.txt’,’mode’,encoding=’xxx’)</code></pre><p>第一个参数是文件的路径名；第三个参数的xxx那里是填入适当的编码格式，假如你的文件是gbk格式的，你打开的时候，为了防止出现乱码，你就得告诉函数，需要用什么格式打开。</p><table><thead><tr><th style="text-align:left">mode</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">r</td><td style="text-align:left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td style="text-align:left">rb</td><td style="text-align:left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</td></tr><tr><td style="text-align:left">r+</td><td style="text-align:left">打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td style="text-align:left">rb+</td><td style="text-align:left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td></tr><tr><td style="text-align:left">w</td><td style="text-align:left">打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">wb</td><td style="text-align:left">以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">w+</td><td style="text-align:left">打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">wb+</td><td style="text-align:left">以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。</td></tr><tr><td style="text-align:left">ab</td><td style="text-align:left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。</td></tr><tr><td style="text-align:left">a+</td><td style="text-align:left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td style="text-align:left">ab+</td><td style="text-align:left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><h4 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h4><pre><code>f = open(&apos;fileTest.txt&apos;, &apos;r&apos;)f = f.read()print(f)</code></pre><p>read()一次性读取文件的全部内容，可以在read(size)里面传参，表示每次读取size个字节的内容。<br>readline() 每次读取文件一行的内容。<br>readlines()一次读取所有内容并按行返回 list。</p><h4 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h4><p>只有调用close()方法时，操作系统才能保证把没有写入的数据全部写入磁盘：</p><pre><code>f = open(&apos;fileTest2.txt&apos;,&apos;w&apos;)f.write(&apos;hello! It`s me!&apos;)f.close()</code></pre><p>对于要写入特定编码的文本文件，可以给open() 的encoding传参：</p><pre><code>f = open(&apos;fileTest2.txt&apos;,&apos;w&apos;,encoding=&apos;gbk&apos;)f.write(&apos;hello! It`s me!&apos;)f.close()</code></pre><p>write()是文件写操作中一个比较简单的操作，它将字符串写入文件，没有返回值。除了这个write()还有writelines()函数，这个函数是向文件写入一个序列字符串列表，换行需要字节添加换行符：</p><pre><code>str = [&apos;你好,&apos;,&apos;欢迎！\n&apos;,&apos;这里是XXX的博客.&apos;]f = open(&apos;fileTest2.txt&apos;,&apos;w&apos;,encoding=&apos;utf-8&apos;)f.writelines(str)f.close()&apos;&apos;&apos;这是运行结果：你好,欢迎！这里是XXX的博客.&apos;&apos;&apos;</code></pre><h4 id="文件其他操作"><a href="#文件其他操作" class="headerlink" title="文件其他操作"></a>文件其他操作</h4><p>seek():指定文件指针的位置，seek(0)把指针移动到文件开头处；<br>tell():获取文件指针的位置；</p><h4 id="关闭文件操作"><a href="#关闭文件操作" class="headerlink" title="关闭文件操作"></a>关闭文件操作</h4><p>我们结束文件操作后，需要调用close()为关闭文件操作符，以免占有内存资源。当然，python为我们提供了更便捷的语句，帮助我们关闭，那就with。上面的代码，修改成下面这个也是行得通的，而且也不用在写close()函数：</p><pre><code>with open(&apos;fileTest.txt&apos;,&apos;r&apos;,encoding=&apos;utf-8&apos;) as f:    for i in f.readlines():        if &apos;XXX&apos; in i:            i = i.replace(&apos;XXX&apos;,&apos;SSS&apos;)        print(i.strip())</code></pre><p>※注意：当使用readline时读取的为整行字符串加上末尾的换行符，要想去掉换行符在赋值的时候需要进行操作：</p><pre><code>i = &quot;hello&quot;j = i[1:]q = i[:-1]print(j+&apos;\n&apos;+q)&quot;&quot;&quot;结果为：ellohell&quot;&quot;&quot;</code></pre><p>要使用[:-1]去掉末尾的换行符。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code># Author:ZTimport getpassregiste = input(&quot;是否拥有账户？(y/n)\n&quot;)if(registe == &quot;n&quot;):    _username = input(&quot;请输入用户名：\n&quot;)    _password = getpass.getpass(&quot;请输入密码：\n&quot;)    _passwordc = getpass.getpass(&quot;请确认密码：\n&quot;)    while _password != _passwordc:        print(&quot;请重新输入用户名和密码&quot;)        _username = input(&quot;请输入用户名：\n&quot;)        _password = getpass.getpass(&quot;请输入密码：\n&quot;)        _passwordc = getpass.getpass(&quot;请确认密码：\n&quot;)    myfile = open(&quot;myaccount.txt&quot;,&apos;w&apos;)    myfile.write(&quot;y\n&quot;)    myfile.write(&quot;{username}\n&quot;.format(username=_username))    myfile.write(&quot;{password}\n&quot;.format(password=_password))    myfile.close()    print(&quot;恭喜你！创建成功！&quot;)elif (registe == &quot;y&quot;):    myaccount = open(&quot;myaccount.txt&quot;,&apos;r+&apos;)    state = myaccount.readline()[:-1]    _usernamer = myaccount.readline()[:-1]    _passwordr = myaccount.readline()[:-1]    if(state == &apos;n&apos;):        print(&quot;SORRY,YOUR ACCOUNT HAS BEEN LOCK,YOU CAN&apos;T LOGIN\nPLEASE CONNECTION WITH SOMEONE!!&quot;)    else:        for i in range(2,-1,-1):            username = input(&quot;请输入用户名：\n&quot;)            password = getpass.getpass(&quot;请输入密码：\n&quot;)            if (username == _usernamer and password == _passwordr):                print(&quot;Welcome user {name}&quot;.format(name=username))                break            else:                if (i == 0):                    myaccount.seek(0)                    myaccount.write(&quot;n\n&quot;)                    print(&quot;账户已被锁定！！！&quot;)                else:                    print(&quot;用户名或密码错误，今日还可输入{n}次&quot;.format(n=i))    myaccount.close()else:    print(&quot;输入无效!!!&quot;)</code></pre><h3 id="功能及不足"><a href="#功能及不足" class="headerlink" title="功能及不足"></a>功能及不足</h3><p>此接口主要实现的功能如下：</p><ul><li>实现了用户的注册和登录，并保持到硬盘</li><li>实现了无回现输入密码，并进行密码确认</li><li>实现了账户的锁定功能</li></ul><p>主要存在的问题如下：</p><ul><li>输入密码的部分代码存在明显的冗余</li><li>从文件取出信息的方式过于繁琐</li><li>锁定账户后可以通过重新注册解锁</li><li>整个程序的流程图不够完善</li><li>无法进行多用户账户管理</li></ul>]]></content>
      
      <categories>
          
          <category> Study </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3.5学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World!</title>
      <link href="/2018/04/03/Hello-World-0/"/>
      <url>/2018/04/03/Hello-World-0/</url>
      <content type="html"><![CDATA[<p>真棒，终于弄好啦媳妇儿。</p><p>爱你，媳妇儿</p>]]></content>
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
